总 : 树上分块
树上路径的询问 考虑树链剖分

但是求的不是区间和等线段树擅长维护的信息 而是有关**"出现"**的询问 我们通常会考虑分块 莫队等算法

首先我们对这棵树进行树链剖分 我们知道树链剖分的子树和重链的 $dfn$ 编号是连续的 

所以我们可以对 $dfn$ 序进行分块

由于值域只有 $30000$ 所以我们采用 `bitset` 来存储每一块的数字的出现状态

当我们已经有了这个`bitset`时 不同的点权我们可以用`bitset`自带的`count`函数获得 这一步的复杂度是 $O(\frac{30000}{w})$

然后查询区间 $MEX$ 我们只需要一位一位遍历即可 找到第一个为 $0$ 的即为答案 如果全都没找到就返回 $30001$

然后我们来看如何处理树上路径

首先先将每个 $dfn$ 序对应的节点上的值记录下来

同时统计出每个块的出现次数的`bitset`

查询时 我们按照树剖的经典逻辑向上跳树链即可

对于某个区间 $[l,r]$ 还是按照散块和整块去处理

散块就让储存答案的`bitset` $ans$ 对应位上置 $1$

而整块就直接让 $ans |=$ 这一块的`bitset`

最后按照上面所说的逻辑处理答案即可 输入要求在线 按照题意模拟即可



所以代码如下

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;


typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 5e5 + 10;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, m, flag, a[maxn], siz[maxn], father[maxn], dep[maxn], son[maxn], dfn[maxn], seg[maxn], tim;
int B, bnum, br[maxn], val[maxn], top[maxn];

bitset<30000> mask[1500], ans;

vector<int> edge[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

void dfs1(int u, int fa) {
    siz[u] = 1;
    father[u] = fa;
    dep[u] = dep[fa] + 1;
    for (auto v : edge[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[son[u]] < siz[v])
            son[u] = v;
    }
}

void dfs2(int u, int root) {
    dfn[u] = ++tim; seg[tim] = u;
    top[u] = root;
    if (son[u] == 0) return;
    dfs2(son[u], root);
    for (auto v : edge[u]) {
        if (v == father[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

void prework() {
    B = sqrt(n * 20);
    bnum = (n - 1) / B + 1;
    for (int i = 1; i <= n; i++) val[i] = a[seg[i]];
    for (int i = 1; i <= bnum; i++)
        br[i] = min(n, B * i);
    for (int i = 1; i <= bnum; i++) 
        for (int j = br[i - 1] + 1; j <= br[i]; j++)
            mask[i].set(a[seg[j]]);
}

void query(int l, int r) {
    int L = (l - 1) / B + 1, R = (r - 1) / B + 1;
    if (L == R) {
        for (int i = l; i <= r; i++)
            ans.set(val[i]);
    }
    else {
        for (int i = l; i <= br[L]; i ++)
            ans.set(val[i]);
        for (int i = L + 1; i <= R - 1; i++)
            ans |= mask[i];
        for (int i = br[R - 1] + 1; i <= r; i++)
            ans.set(val[i]);
    }
}

void queryPath(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        query(dfn[top[u]], dfn[u]);
        u = father[top[u]];
    }
    query(min(dfn[u], dfn[v]), max(dfn[u], dfn[v]));
}

int First() {
    for (int i = 0; i <= 30000; i++)
        if (!ans[i]) return i;
    return 30001;
}

void solve(int id) {
    cin >> n >> m >> flag;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs1(1, 0);
    dfs2(1, 1);
    prework();
    int lastans = 0;
    while (m--) {
        int Q;
        cin >> Q;
        ans.reset();
        while (Q--) {
            int u, v;
            cin >> u >> v;
            if (flag) u ^= lastans, v ^= lastans;
            queryPath(u, v);
        }
        int ans1 = ans.count(), ans2 = First();
        lastans = ans1 + ans2;
        cout << ans1 << " " << ans2 << "\n";
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```

