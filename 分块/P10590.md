由题 每个磁石拥有坐标 质量 磁力 半径 四个属性

而人所在的位置是永远不变且已知的 那么我们可以稍作转换 将属性"坐标" 改为 "距离"

一个很显然的想法是 $BFS$ 每个磁石去找它能够吸引的磁石 加入队列 

但是这样做的最坏复杂度是 $O(N^2)$ 的

那么我们考虑对磁石进行分块

我们将磁石按照距离 $d$ 进行排序 然后分成若干块 不妨将块长定义为 $\sqrt{N}$ 

那么我们处理出每一块的右端点、每一块的距离最大值 $maxd$

同时 块内我们再按照质量 $m$ 进行升序排序

然后 当我们进行 $BFS$ 时 假设当前磁石的半径为 $r$ 磁力为 $power$ 我们一块一块的考虑

如果当前块 $i$ 的 $maxd\le d$  那么我们去遍历块中的每一个点磁石

由于我们已经按照质量升序排序了 所以我们如果当前块的第 $j$ 个磁石已经符合条件了

那么我们之后的 $BFS$ 过程中 永远都不需要再判断 $j$ 了

所以我们还需要再添加一个数组 $bl$ 来记录当前块的左端点编号

那么显然 $bl$ 是不会回退只会增大的

如果当前块 $i$ 的 $maxd > d$ 了 那么我们遍历这个块

找到 $d$ 和 $m$ 都符合条件的磁块 放入队列中 同时给其 $vis$ 数组标记为 $1$ 

让以后的节点 无论是哪种情况 都不要再让其入队

做完后 直接 $break$ 即可因为我们虽然每块之间是按照 $m$ 排序的 但是块与块之间能保证后一个块的 $d$ 一定大于前一个块 所以无须继续循环

这样 由于 $maxd \le d$ 的遍历不会回退 而每一次 $maxd > d$ 的最多只做一个块 

所以整体时间复杂度为 $O(N\sqrt{N})$





```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

#define int long long
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 5e5 + 10;
constexpr int base = 131;
constexpr int eps = 1e-7;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int x_0, y_0, pL, rL, n, B, br[maxn], bnum, maxm[maxn], le[maxn];
bool vis[maxn];

struct node {
    int m, p, r, d;
} ev[maxn];

bool cmp(node c1, node c2) {
    return c1.m < c2.m;
}

bool comp(node c1, node c2) {
    return c1.d < c2.d;
}

struct no {
    int power, r;
};

void prework() {
    B = sqrt(n);
    bnum = (n - 1) / B + 1;
    for (int i = 1; i <= bnum; i++) br[i] = min(B * i, n);
    for (int i = 1; i <= bnum; i++) 
        maxm[i] = ev[br[i]].m;
    for (int i = 1; i <= bnum; i++) {
        le[i] = br[i - 1] + 1;
        sort(ev + le[i], ev + br[i] + 1, comp);
    }
}

void solve(int id) {
    cin >> x_0 >> y_0 >> pL >> rL >> n;
    rL *= rL;
    for (int i = 1; i <= n; i++) {
        int x, y;
        cin >> x >> y >> ev[i].m >> ev[i].p >> ev[i].r;
        ev[i].d = (x - x_0) * (x - x_0) + (y - y_0) * (y - y_0);
        ev[i].r *= ev[i].r;
    }
    sort(ev + 1, ev + n + 1, cmp);
    prework();
    queue<no> q;
    q.push({ pL,rL });
    int ans = 0;
    while (!q.empty()) {
        ans++;
        int power = q.front().power, R = q.front().r;
        q.pop();
        for (int i = 1; i <= bnum; i++) 
            if (power >= maxm[i]) {
                int l = le[i], r = br[i];
                while (l <= r && (R >= ev[l].d || vis[l])) {
                    if (!vis[l])
                        q.push({ ev[l].p,ev[l].r }), vis[l] = 1;
                    l++;
                }
                le[i] = l;
            }
            else {
                for (int j = br[i - 1] + 1; j <= br[i]; j++)
                    if (ev[j].m <= power && ev[j].d <= R && !vis[j]) {
                        q.push({ ev[j].p,ev[j].r });
                        vis[j] = 1;
                    }
                break;
            }
    }
    cout << ans - 1 << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```

