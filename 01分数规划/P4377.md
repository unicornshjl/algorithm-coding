看到"最大的才艺与重量的比值" 很容易发现这题是一道分数规划

记第 $i$ 头奶牛的重量为 $a[i]$ 才艺为 $b[i]$ 

那么我们直接二分答案 假设当前的答案为 $mid$ 

然后套路地 $c[i] = b[i] - mid \times a[i] $

我们要从中选出奶牛的条件是 : 总重量至少为 $W$ 

那么对于第 $i$ 头奶牛 我们可以将 $a[i]$ 仍然视作重量 $c[i]$ 视为其价值

我们要做的就是一个**背包容量为 $W$ 物品重量为 $a[i]$ 价值为 $c[i]$ 的 $01$ 背包**

如果最终的 $f[W] \geq \epsilon$ 那么当前答案是合法的

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<random>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<utility>
#include<unordered_map>
#include<unordered_set>
#include<bitset> 
using namespace std;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int maxn = 2e5 + 10;
constexpr int maxm = 100 + 10;
constexpr int intinf = 1e9 + 10;
constexpr int mod = 998244353;
constexpr ll inf = 1e15 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };
constexpr ld eps = 1e-8;
using namespace std;
int n, m, a[maxn], b[maxn];
ld f[1010], c[maxn];

void init() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i] >> b[i];
}

bool check(ld mid) {
	for (int i = 1; i <= m; i++) f[i] = -inf;
	for (int i = 1; i <= n; i++)
		c[i] = (ld)b[i] - (ld)a[i] * mid;
	f[0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = m; j >= 0; j--) {
			int k = min(j + a[i], m);
			f[k] = max(f[k], f[j] + c[i]);
		}
	}
	return f[m] > eps;
}

void solve() {
	ld l = 0, r = 1000, ans = 0;
	int sum = 0;
	while (sum < 75) {
		sum++;
		ld mid = (l + r) / 2;
		if (check(mid)) {
			l = mid;
			ans = mid;
		}
		else r = mid;
	}
	ans = ans * 1000;
	cout << int(ans) << "\n";
}

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	init();
	solve();
	return 0;
}
```

