看到题目中的表达式为略微变形后的分数规划的式子 直接考虑使用分数规划法二分答案

然后我们假设当前二分的答案为 $mid$ 要满足的式子是 $\frac{1}{k}\sum_{i = 1}^{k} w_{c_i,c_i + 1} \le mid $ 即 $\sum_{i = 1}^{k} w_{c_i,c_i + 1} \le mid \times k$

也就是 $\sum_{i = 1}^{k} w_{c_i,c_i + 1} - k \times mid \le 0$

那么就意味着至少存在一组选择使得 $\sum_{i = 1}^{k} (w_i-mid) \le 0$ 由于浮点数误差 我们也可以将式子化为 $\sum_{i = 1}^{k} (w_i-mid) < 0$ 

这就表明了 我们可以以 $w_i - mid$ 作为新的边权 去寻找图中是否存在一个**负环** 

只需要找到一个负环即可 我们可以采用更为好写的 $DFS$ 来判断负环 实际上和 $SPFA$ 差不多 只是写法上略有不同

代码如下 

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<random>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<utility>
#include<unordered_map>
#include<unordered_set>
#include<bitset> 
using namespace std;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int maxn = 2e5 + 10;
constexpr int maxm = 100 + 10;
constexpr int intinf = 1e9 + 10;
constexpr int mod = 998244353;
constexpr ll inf = 1e15 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };
constexpr ld eps = 1e-12;
using namespace std;
int n, m, u[maxn], v[maxn], cnt, head[maxn], to[maxn], nxt[maxn];
bool vis[maxn];
ld val[maxn], dis[maxn], w[maxn];

void init() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
		cin >> u[i] >> v[i] >> w[i];
}

void add(int u, int v, ld w) {
	to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; val[cnt] = w;
}

bool spfa(int u) {
	vis[u] = 1;
	bool flag = false;
	for (int i = head[u]; i; i = nxt[i]) {
		int v = to[i];
		if (dis[v] > dis[u] + val[i]) {
			if (vis[v]) return true;
			dis[v] = dis[u] + val[i];
			flag |= spfa(v);
		}
	}
	vis[u] = 0;
	return flag;
}

bool check(ld mid) {
	cnt = 0;
	for (int i = 0; i <= n; i++)
		head[i] = 0, dis[i] = 0, vis[i] = 0;
	for (int i = 1; i <= m; i++) 
		add(u[i], v[i], (ld)w[i] - mid);
	for (int i = 1; i <= n; i++)
		if (spfa(i)) return true;
	return false;
}

void solve() {
	ld l = -10000000, r = 10000000, ans;
	int sum = 0;
	while (sum < 100) {
		sum++;
		ld mid = (l + r) / 2;
		if (check(mid)) {
			r = mid;
			ans = mid;
		}
		else l = mid;
	}
	cout << fixed << setprecision(8) << ans << "\n";
}

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	init();
	solve();
	return 0;
}
```

