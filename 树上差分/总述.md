## 树上差分（Tree Difference Technique）

树上差分是一种高效处理 **树上路径或子树加减操作** 的技巧，适用于点权或边权的区间修改问题。
 它的核心思想是 **利用差分数组 + $DFS$ 累加**，将路径或子树的修改转化为局部更新，再通过一次 $DFS$ 推导出最终答案。

一般用于只有一次询问或所有询问都可以离线下来一次性处理  否则应使用**树链剖分**来解决

------

### 一、点差分（Node Difference）

**问题描述 (Query)：**
 给定一棵树，有 $Q$ 次操作，每次操作要求将从节点 `x` 到节点 `y` 的所有 **节点权值** 增加 `v`。

**解法 (Solution)：**

1. 使用差分数组记录增量：

```
sum[x] += v
sum[y] += v
sum[LCA(x, y)] -= v
sum[parent[LCA(x, y)]] -= v
```

1. DFS 遍历树，累加每个节点的增量：

```
dfs(u):
    for v in children(u):
        dfs(v)
        sum[u] += sum[v]
```

- 遍历完成后，`sum[u]` 就表示节点 `u` 的最终权值。
- 优点：每次操作时间复杂度为 $O(1)$，只需一次 DFS 推导最终结果。

------

### 二、边差分（Edge Difference）

**问题描述 (Query)：**
 给定一棵树，有 $Q$ 次操作，每次操作要求将从节点 `x` 到节点 `y` 的所有 **边权** 增加 `v`。

**解法 (Solution)：**

1. 将边权转化为点权，然后使用差分数组：

```
sum[x] += v
sum[y] += v
sum[LCA(x, y)] -= 2 * v
```

1. $DFS$ 遍历树，同时更新边权和点权：

```
dfs(u):
    for v in children(u):
        dfs(v)
        for each edge e connecting u and v:
            w[e] += sum[v]    // 更新边权
        sum[u] += sum[v]      // 更新点权
```

- `w[e]` 表示边 `e` 的权值
- `sum[u]` 表示节点权值
- 原理与点差分类似，通过差分和累加实现区间/路径的快速更新。

------

### 三、树上差分 + 树状数组

- 树上差分也可以结合 **树状数组 (Fenwick Tree)** 优化。
- 原理：DFS 中每个节点 `u` 的子树（包括自身）在 DFS 序中是连续区间。
- 利用 DFS 序，可以将子树修改与查询转化为 **区间修改 + 单点查询** 的树状数组操作，从而支持在线操作。

**示意：**

```
// 预处理 DFS 序
st[u], ed[u] = dfs_order(u)

// 区间修改
BIT.add(st[u], ed[u], v)

// 查询节点 u
res[u] = BIT.query(st[u])
```

- 优点：
  - 支持快速的子树增量修改
  - 可结合其他树上算法，如树链剖分、树上莫队
  - 时间复杂度通常为 $O(\log n)$ 每次修改/查询
