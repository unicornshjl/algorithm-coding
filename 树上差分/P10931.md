我们要在两个不同部分分别破坏掉一条边

那么我们可以两部分分开来考虑

比如 对于一条旧的边 考虑何时它是有贡献的

假设 我们让每一条新边尝试从旧的边上去走 走过的边标记 $+1$

那么对于一条旧的边 如果这条边上的标记为 $0$ 那么就意味着 没有一条新边经过它 

也就是说我们断开这条边的话 断开任意一条新边都是可以的 贡献 $+m$

而如果这条边上的标记为 $1$ 说明恰好有一条新边会经过它 那么我们把那条边断开即可 贡献 $+1$

那么这道题就被转化成了一个边差分的问题



代码如下 :

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<cmath>
#include<cstring>
#include<string>
#include<set>
#include<unordered_set>
#include<unordered_map>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<climits>
#include<bitset>

using namespace std;

typedef long long ll;

constexpr int maxn = 4e5 + 10;
constexpr int N = 21;
constexpr int B = 2e5;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 4e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

int n, m, dep[maxn]， f[maxn][N]， num[maxn]， sum[maxn];
vector<pair<int, int>> edge[maxn];

void add(int u, int v,int w) {
    edge[u].push_back({ v,w });
}

void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for (int i = 1; i < N; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (auto [v, _] : edge[u]) {
        if (v == fa) continue;
        dfs(v， u);
    }
}

int get_lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u， v);
    int k = dep[u] - dep[v];
    for (int i = N - 1; i >= 0; i--)
        if ((k >> i) & 1)
            u = f[u][i];
    if (u == v) return u;
    for (int i = N - 1; i >= 0; i--)
        if (f[u][i] != f[v][i])
            u = f[u][i]， v = f[v][i];
    return f[u][0];
}

void query(int u, int fa) {
    for (auto [v， w] : edge[u]) {
        if (v == fa) continue;
        query(v， u);
        num[u] += num[v];
        sum[w] += num[v];
    }
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u， v, i);
        add(v， u, i);
    }
    dfs(1, 0);
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        num[u]++; num[v]++; num[get_lca(u， v)] -= 2;
    }
    query(1, 0);
    int ans = 0;
    for (int i = 1; i < n; i++) {
        if (sum[i] == 0) ans += m;
        if (sum[i] == 1) ans += 1;
    }
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```

