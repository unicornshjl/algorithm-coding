- 参考了 $SUA-wiki$ 上的内容 这里的图片和表述非常不错

首先 我们很容易发现的一个事实是 每一次染色之后影响某些**同一深度**的节点 所以我们每次**只考虑某一个深度的答案** 最后将所有深度的答案全部加起来即可

此外 还有一个很显然的事实是 深度大的点不可能会染到深度小的点上 那么当我们考虑深度为 $D$ 的节点时 所有深度大于 $D$ 的节点都可以被删去 因此深度为 $D$ 的节点成为了新的叶子结点

因此 考虑染黑深度为 $D$ 的节点

$D = 1$ 时 只有根节点能染自己 所以直接将 $a_0$ 加入 $ans$ 即可

假设 $D>1$ 我们记 $f(u)$ 表示根节点为 $u$ 的子树中 叶子结点需要染黑的最小代价 记 $u$ 的节点深度为 $d_u$ 而所有 $u$ 的儿子记作 $son(u)$

那么我们有如下的转移方程 

$$
f(u) = \min(a_{D - d_u}, \sum\limits_{v \in \text{son}(u)} f(v))
$$
 

前者表示我在 $u$ 这个节点一次性将叶子结点染黑 后者表示父节点不动 全部靠子节点染黑

这是因为如果既让父节点行动又让子节点行动 代价一定是 $\geq a_{D-d_u}$ 的

最终答案即为 $f(1)$

那么我们需要枚举深度 $D$ 而对于每一个深度 $D$ 都需要进行一次树形 $DP$ 时间复杂度为 $O(N^2)$ 无法接受



我们发现 复杂度瓶颈主要是在树形 $DP$ 上 因为每次都需要遍历完几乎 $N$ 个节点才能得到最终的答案

那么有没有什么办法降低节点数呢 ? 显然是有的 采用 **虚树** 

事实上 当已经确定了一个 $D$ 时 我们可以将此深度的点视为**关键节点** 因为最终的答案就是染黑这些**关键节点**所需要的答案 与其他节点的关系并不那么密切

而我们每次都需要得到 $f(1)$ 的值 所以我们还需要将 $1$ 加入节点

建出虚树后 我们考虑原先的 $DP$ 转移方程有了何种变化

还是考虑两个方面 一方面是 **全部交给子节点** 那么在虚树上 子节点就是**虚树上的子节点**

另一方面是由当前节点自己独立完成 在虚树上 对于一个节点 $u$ 假设他的父亲为 $fa_u$ 那么这两个节点之间在原树中可能并不相邻 那么让父节点 $u$ 独立完成 实际上就是 **让 $fa_u$ 的儿子到 $u$ 这些节点中代价最小的点去完成** 

也就是说 我们的式子变为了

$$
f(u) = \min(\min\limits_{i = d_{fa_u} + 1}^{d_u} a_{D - i}, \sum\limits_{v \in \text{virt-son}(u)} f(v))
$$

我们可以用如下图片来更直观的看出 虚树加速了一条链上的 $DP$ 值的计算

![e-editorial.png](https://sua.ac/wiki/2022-icpc-nanjing/e-editorial.png)



转移方程中的第二项是很好求的 遍历每个儿子即可 而第一项实际上就是一个**静态区间最小值**问题 这个问题我们可以采用 `ST表` 求解

另外需要注意一下边界条件 也就是叶子节点只能靠 **自己染色** 其子**节点染色的代价**应该设为 $+ \infty$

最终答案仍然是 $f(1)$ 的值

建立虚树的复杂度为 $O(N\log N)$ 而 `ST表` 的时间复杂度也为 $O(N\log N)$ 所以总时间复杂度为 $O(N\log N)$



所以代码如下

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

#define int long long
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 6e5 + 10;
constexpr int N = 21;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };


int n, a[maxn], dep[maxn], f[maxn][N], dfn[maxn], tim, cnt, st[maxn][N];

vector<int> edge[maxn], V[maxn], to[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

int query(int l, int r) {
    if (l > r) return inf;
    int len = log2(r - l + 1);
    return  min(st[l][len], st[r - (1 << len) + 1][len]);
}

void ST() {
    for (int i = 1; i < N; i++)
        for (int j = 0; j + (1 << i) - 1 < n; j++)
            st[j][i] = min(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);

}

int get_lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int k = dep[u] - dep[v];
    for (int i = N - 1; i >= 0; i--)
        if ((k >> i) & 1) u = f[u][i];
    if (u == v) return u;
    for (int i = N - 1; i >= 0; i--)
        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
}

void dfs(int u, int fa) {
    dfn[u] = ++tim;
    dep[u] = dep[fa] + 1;
    V[dep[u]].push_back(u);
    f[u][0] = fa;
    for (int i = 1; i < N; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (auto v : edge[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
}

bool cmp(int x, int y) {
    return dfn[x] < dfn[y];
}

int dp(int u,int fa,int d) {
    int son = 0;
    if (to[u].empty()) son = inf;
    else for (auto v : to[u]) 
            son += dp(v, u, d);
    int self = query(d - dep[u], d - dep[fa] - 1);
    return min(self, son);
}

void solve(int id) {
    cin >> n;
    tim = 0;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++)
        st[i][0] = a[i];
    ST();
    for (int i = 1; i <= n; i++) edge[i].clear(), V[i].clear();
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs(1, 0);
    int ans = st[0][0];
    for (int i = 2; i <= n; i++) {
        int sum = V[i].size();
        if (sum == 0) continue;
        cnt = 0;
        for (auto v : V[i]) 
            a[++cnt] = v;
        sort(a + 1, a + cnt + 1, cmp);
        for (int j = 1; j < sum; j++) {
            int u = a[j], v = a[j + 1];
            int lca = get_lca(u, v);
            a[++cnt] = lca;
        }
        a[++cnt] = 1;
        sort(a + 1, a + cnt + 1, cmp);
        cnt = unique(a + 1, a + cnt + 1) - a - 1;
        for (int j = 1; j < cnt; j++) {
            int u = a[j], v = a[j + 1];
            int lca = get_lca(u, v);
            to[lca].push_back(v);
        }
        ans += dp(1, 0, i);
        for (int j = 1; j < cnt; j++) {
            int u = a[j], v = a[j + 1];
            int lca = get_lca(u, v);
            to[lca].clear();
        }
    }
    cout << ans << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```
