题目中涉及到了“丰富资源岛屿”的概念 实际上 这正对应了我们虚树中提到的**关键点** 

注意到 $\sum k_i \le 5\times 10^5$  我们可以采用虚树来处理这个问题

然后我们考虑如何建出虚树 显然所提供的点一定是作为关键点被加入虚树节点中的 

又因为我们的目标是让所有关键点无法与 $1$ 号点建立联系 所以我们也要将 $1$ 号点也放入虚树

那么树上的边权应该如何考虑呢 显然 对于虚树上的两点 $u$ 和 $v$ 由于题目要求的是最小代价 

我们将 $u$ 和 $v$ 这整条路径中的最小路径当做 $u$ 和 $v$ 这条边的边权

如何处理呢?  其实很简单 建树按照两次排序方法即可 

而维护 $u$ 到 $v$ 路径上的最小边权这个问题 , 由于我们建虚树时保证了 $u$ 一定是 $v$ 的祖先 所以可以直接使用倍增法来解决

然后如何得到最终答案呢 我们采用树形 $DP$ 

对于一个点 $u$ 若它的子节点 $v$ 为关键节点 那么 $u$ 和 $v$ 是一定要断开的 所以 $dp[u] += w_{u\to v}$ 

​			若它的子节点 $v$ 不是关键节点 那么 $u$ 和 $v$ 不一定要断开 但是 $v$ 的子树里是一定存在关键点的 所以我们的抉择就是 要么 断开当前这条边  要么让 $v$ 的子树自己断开 所以 $cost[u]+=\min(w_{u \to v}, cost[v])$  边界条件显然 叶子结点的 $cost$ 值为0



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

#define int long long

constexpr int maxn = 6e5 + 10;
constexpr ll inf = 1e15;

int n, dep[maxn], f[maxn][N], st[maxn][N], dfn[maxn], tim, k, key[maxn], cnt, a[maxn], cost[maxn];

bool iskey[maxn];

vector<pair<int, int>> edge[maxn], to[maxn];

void add(int u, int v, int w) {
    edge[u].push_back({ v, w });
}

void ST() {
    for (int i = 1; i < N; i++) 
        for (int j = 1; j <= n; j++) {
            int to = f[j][i - 1];
            f[j][i] = f[to][i - 1];
            st[j][i] = min(st[j][i - 1], st[to][i - 1]);
        }
}

int get_lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int k = dep[u] - dep[v];
    for (int i = 0; i < N; i++)
        if ((k >> i) & 1) u = f[u][i];
    if (u == v) return u;
    for (int i = N - 1; i >= 0; i--)
        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
}

void dfs(int u, int fa) {
    dfn[u] = ++tim;
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for (auto [v, w] : edge[u]) {
        if (v == fa) continue;
        st[v][0] = w;
        dfs(v, u);
    }
}

int get_dis(int v, int u) {
    int k = dep[u] - dep[v], res = inf;
    for (int i = N - 1; i >= 0; i--)
        if ((k >> i) & 1) res = min(res, st[u][i]), u = f[u][i];
    return res;
}

bool cmp(int x, int y) {
    return dfn[x] < dfn[y];
}

void dp(int u) {
    cost[u] = 0;
    for (auto [v, w] : to[u]) {
        dp(v);
        if (iskey[v]) cost[u] += w;
        else cost[u] += min(cost[v], w);
    }
}

void solve(int id) {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w); add(v, u, w);
    }
    dfs(1, 0);
    ST();
    int Q; cin >> Q;
    while (Q--) {
        cin >> k;
        cnt = 0;
        for (int i = 1; i <= k; i++)
            cin >> key[i], iskey[key[i]] = 1, a[++cnt] = key[i];
        sort(a + 1, a + k + 1, cmp);
        for (int i = 1; i <= k - 1; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            a[++cnt] = lca;
        }
        a[++cnt] = 1;
        sort(a + 1, a + cnt + 1, cmp);
        cnt = unique(a + 1, a + cnt + 1) - a - 1;
        for (int i = 1; i < cnt; i++) {
            int u = a[i], v = a[i + 1]; 
            int lca = get_lca(u, v);
            to[lca].push_back({ v,get_dis(lca,v) });
        }
        dp(1);
        cout << cost[1] << "\n";
        for (int i = 1; i < cnt; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            to[lca].clear();
        }
        for (int i = 1; i <= k; i++)
            iskey[key[i]] = 0;
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```



