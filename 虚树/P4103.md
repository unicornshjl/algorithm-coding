$P4103$

注意到每次只选中 $k$ 个关键节点 而  $\sum k \le 2\times n,n \le 10^6$  所以考虑建立虚树

按照两次排序法建立起虚树后 我们考虑如何计算答案

我们要求的是 1.任意两点距离和 2.任意两点最小距离 3.任意两点最大距离

受到树上求直径的树形 $DP$ 做法的启发 我们考虑如何利用树形 $DP$ 来解决这个问题

首先 在本题中所有的边权均为 $1$ 那么我们就无须额外计算边权

因为在转移的过程中 我们只涉及到 $u$ 以及其子节点 $v$ 之间的距离 这显然是可以通过深度差快速计算的

我们来分别考虑这三个问题的解

- 任意两点距离和 记为 $anssum$

​	记 $sum[u]$ 为 $u$ 当前所有子树到达 $u$ 的距离和 $siz[u]$ 为 $u$ 子树内部的节点个数

​	考虑当前为 $u \to v $ 的一条边 利用深度差算出 $u$ 和 $v$ 两点距离 $cur$

​	$anssum$ 需要加的部分为 实际上就是 $u$ 的子树 到 $v$ 的子树任意两点的距离

​	那么我们可以将其拆为几部分处理 首先是 **$u$ 子树内的所有节点到 $u$ 的距离** $sum[u]$ 由于需要到达的节点有 $siz[v]$ 个 所以我们要 $+siz[v] \times sum[u]$ 然后是子树上**这些节点到达 $u$ 后前往 $v$ 的距离** 由于目标点仍然是 $siz[v]$ 个 所以需要 $+siz[u]\times cur\times siz[v]$ 最后是这些节点分别抵达 $v$ 子树上不同的节点 显然这和 $v$ 子树上所有节点到达 $v$ 点的距离是一样的 即为 $sum[v]$ 由于 $u$ 子树上节点有 $siz[u]$ 个 所以还需要 $+sum[v] \times siz[u]$ 

​	同时 $sum[u]$ 也要更新 $v$ 所有子树全部合并到 $u$ 上来 需要加上的是 $v$ 子树上所有点到 $u$ 的距离 不难发现是 $sum[v] + siz[v]\times cur$

- 任意两点最近距离和任意两点最远距离 分别记为 $ansmin$ 和 $ansmax$

​	我们用 $MIN[u]、MAX[u]$ 来表示距离当前点最近和最远点的关键点的距离

​	考虑初始化 如果当前节点 $u$ 是一个关键点 那么 $MIN[u] = MAX[u] = 0$ 否则 $MIN[u] = inf,MAX[u] = -inf$

​	考虑当前为 $u\to v$ 的一条边 利用深度差算出 $u$ 到 $v$ 两点的距离 $cur$

​	那么也就是 考虑 $u$ 的子树 $\to$ $u$ $\to $ $v$ $\to$ $v$ 的子树的距离

​	那么如何更新? $ansmin = \min(ans,MIN[u] + cur + MIN[v])、ansmax = \max(ans,MAX[u] + cur + MAX[v])$ 

​	而 $MIN[u]$  和 $MAX[u]$ 又增加了 $v$ 子树上的选择 $MIN[u] = \min(MIN[u],cur + MIN[v])$ 

​                                                                                                $MAX[u] = \min(MAX[v],cur + MAX[v])$

由此我们就得到了本题的答案

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

#define int long long
typedef long long ll;

constexpr ll mod = 998244353;

constexpr int maxn = 2e6 + 10;
constexpr int N = 23;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, dep[maxn], dfn[maxn], tim, f[maxn][N], cnt, a[maxn], key[maxn], MIN[maxn], MAX[maxn], sum[maxn], len[maxn];
int anssum, ansmin, ansmax, siz[maxn];

bool iskey[maxn];

vector<int> edge[maxn], to[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

int get_lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int k = dep[u] - dep[v];
    for (int i = 0; i < N; i++)
        if ((k >> i) & 1)  u = f[u][i];
    if (u == v) return u;
    for (int i = N - 1; i >= 0; i--)
        if (f[u][i] != f[v][i])
            u = f[u][i], v = f[v][i];
    return f[u][0];
}

void dfs(int u, int fa) {
    dfn[u] = ++tim;
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for (int i = 1; i < N; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (auto v : edge[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
}

bool cmp(int x, int y) {
    return dfn[x] < dfn[y];
}

void dp(int u) {
    sum[u] = 0;
    if (iskey[u]) {
        siz[u] = 1;
        MIN[u] = MAX[u] = 0;
    }
    else {
        siz[u] = 0;
        MIN[u] = inf;
        MAX[u] = -inf;
    }
    for (auto v : to[u]) {
        dp(v);
        int cur = dep[v] - dep[u];
        anssum += sum[u] * siz[v] + cur * siz[u] * siz[v] + sum[v] * siz[u];
        ansmin = min(ansmin, MIN[v] + cur + MIN[u]);
        ansmax = max(ansmax, MAX[v] + cur + MAX[u]);
        sum[u] += sum[v] + siz[v] * cur;
        siz[u] += siz[v];
        MIN[u] = min(MIN[u], MIN[v] + cur);
        MAX[u] = max(MAX[u], MAX[v] + cur);
    }
}

void solve(int id) {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs(1, 0);
    int Q; cin >> Q;
    while (Q--) {
        int k;
        cin >> k;
        cnt = 0;
        for (int i = 1; i <= k; i++) {
            cin >> key[i]; a[++cnt] = key[i]; iskey[key[i]] = 1;
        }
        sort(a + 1, a + cnt + 1, cmp);
        for (int i = 1; i < k; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            a[++cnt] = lca;
        }
        sort(a + 1, a + cnt + 1, cmp);
        cnt = unique(a + 1, a + cnt + 1) - a - 1;
        for (int i = 1; i < cnt; i++){
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            to[lca].push_back(v);
        }
        anssum = 0, ansmin = inf, ansmax = -inf;
        dp(a[1]);
        cout << anssum << " " << ansmin << " " << ansmax << "\n";
        for (int i = 1; i < cnt; i++) {
            int u = a[i], v = a[i + 1];
            int lca = get_lca(u, v);
            to[lca].clear();
        }
        for (int i = 1; i <= k; i++)
            iskey[key[i]] = false;
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```
