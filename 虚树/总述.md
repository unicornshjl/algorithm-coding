## 一、 何谓虚树？

1. **问题背景：** 当我们处理一棵大树（$N$ 个节点）上的多组询问时，如果每次询问只涉及树上的一小部分**关键节点**（$k$ 个节点），并且答案主要由这些关键节点及其关系决定。
2. **核心定义：** 虚树是一棵“压缩”后的树。它只包含以下两种节点：
   - **关键节点** (Key Nodes)。
   - 所有关键节点对的**最近公共祖先 (LCA)**。
3. **结构：** 虚树保留了这些节点在原树上的祖先-后代关系，从而构成一棵规模更小的新树。

## 二、 虚树的使用（目的与优势）

1. **应用场景：** 多组询问，且所有询问的**关键节点总数**（$\sum k$）在一个可接受的范围内（例如 $\sum k \le 10^6$）。
2. **核心用法：** 针对每次询问，我们不直接在原树（规模 $O(n)$）上操作，而是先构建出虚树（规模 $O(k)$），然后在虚树上求解（例如进行树形DP、最短路等）。
3. **复杂度优化：** 虚树的节点规模远小于原树（$O(k)$ 远小于 $O(n)$），这使得原先 $O(n)$ 或 $O(n \log n)$ 的单次操作，被优化到 $O(k)$ 或 $O(k \log n)$，从而使总复杂度得以接受。

## 三、 两次排序法建立虚树

这是一种实现相对简单的建树方法，它分为“确定节点”和“构建边”两个步骤。

### 1. 确定节点

1. **获取节点：** 得到当次询问的 $k$ 个关键节点，存入集合 $S$。
2. **（可选）加入根：** 根据题目要求，判断是否需要将原树的根节点（例如1号节点）加入 $S$。（**注：** 即使根节点不是关键节点，也常常需要加入，以保证虚树的连通性）。
3. **排序 (第一次)：** 将 $S$ 中的所有节点按照**dfn序**（DFS序）从小到大排序。
4. **加入LCA：** 遍历排序后的 $S$，对于**相邻**的两个节点 $S[i]$ 和 $S[i+1]$，求出它们的 $\text{LCA}(S[i], S[i+1])$，并将这个LCA节点也加入 $S$ 中。
5. **排序与去重 (第二次)：** 再次对集合 $S$ 按照 **dfn序** 排序，并进行**去重**（`sort` + `unique`）。
   - 此时，集合 $S$ 中就包含了虚树需要的所有节点。

### 2. 构建边

1. **遍历节点：** 遍历上一步得到的、按dfn序排好且去重的最终节点数组 $S$。
2. **连接关系：** 假设当前节点为 $u$（即 $S[i]$），下一个节点为 $v$（即 $S[i+1]$），那么 $v$ 在虚树上的父亲 **必定** 是 $\text{LCA}(u, v)$。
3. **建立边：** 我们连接一条从 $\text{LCA}(u, v)$ 指向 $v$ 的边（根据需要确定单向或双向）。
   - **重要：** 由于 $S$ 中包含了所有必要的LCA，$\text{LCA}(u, v)$ 节点必然已经存在于 $S$ 中。
   - **边权处理：** 虚树的边 $(p, v)$ 常常需要一个权值，这个权值通常是原树上 $p$ 到 $v$ 的路径长度（或节点数等），即 $\text{depth}[v] - \text{depth}[p]$。

## 四、 复杂度分析

1. **节点规模：** 假设关键节点有 $k$ 个。在加入了LCA之后，虚树的节点总数 $m$ 满足 $k \le m < 2k$。因此，虚树的规模为 $O(k)$。
2. **建立时间：** $O(k \log n)$（假设使用倍增法求LCA，查询复杂度为 $O(\log n)$）
   - **dfn序排序 (两次)：** $O(k \log k)$。
   - **加入LCA (步骤1.4)：** 遍历 $k$ 次，每次求LCA，总共 $O(k \log n)$。
   - **构建边 (步骤2.3)：** 遍历 $O(k)$ 次，每次求LCA，总共 $O(k \log n)$。
   - **瓶颈：** 复杂度瓶颈在于求LCA，总时间复杂度为 $O(k \log n)$。

## 五、 总结

虚树本身不是一个算法，而是一种**优化技巧**。它将一个在大树上无法承受的复杂操作，通过“压缩”信息，转移到了一个规模 $O(k)$ 的小树上，是解决树上多组询问、点集相关问题的利器。
