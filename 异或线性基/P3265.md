本题实际上为 [$P4570$](https://github.com/unicornshjl/algorithm-coding/blob/main/%E5%BC%82%E6%88%96%E7%BA%BF%E6%80%A7%E5%9F%BA/P4570.md) 的强化版

区别在于本题要求的不是异或下的线性基 而是加法下的线性基也就是 **向量空间下的线性基**

思路仍然是贪心 然后构造线性基即可

那么我们改一下构造线性基的板子 将异或全部改为对应的加减法就能解决本题



```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<random>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<utility>
#include<unordered_map>
#include<unordered_set>
#include<bitset> 
using namespace std;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int maxn = 2e5 + 10;
constexpr int maxm = 64 + 10;
constexpr int intinf = 1e9 + 10;
constexpr int mod = 998244353;
constexpr ll inf = 1e15 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };
constexpr ld eps = 1e-3;
using namespace std;

int n, m;
ll a[505][505];
ld b[505];
pair<int, int> cost[505];
bool flag[505];
ld base[505][505];

void init() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
	for (int i = 1; i <= n; i++)
		cin >> cost[i].first, cost[i].second = i;
	sort(cost + 1, cost + n + 1);
}

bool insert(ll x) {
	for (int i = 1; i <= m; i++)
		b[i] = a[x][i];
	for (int i = 1; i <= m; i++) {
		if (abs(b[i]) <= eps) continue;
		if (!flag[i]) {
			for (int j = 1; j <= m; j++) {
				base[i][j] = b[j];
			 }
			flag[i] = true;
			return true;
		}
		else {
			ld k = b[i] / base[i][i];
			for (int j = i; j <= m; j++)
				b[j] -= base[i][j] * k;
		}
	}
	return false;
}

void solve() {
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		if (insert(cost[i].second))
			ans += cost[i].first;
	}
	int sum = 0;
	for (int i = 1; i <= n; i++) sum += flag[i];
	cout << sum << " " << ans << "\n";
}

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	init();
	solve();
	return 0;
}
```

