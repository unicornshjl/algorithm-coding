要求某个点为根时的最大代价，容易想到换根 $DP$ 。

$dp[1]$ 的值是好求的。我们设以 $u$ 为根，只包含子树的总流量为 $flow[u]$ ，那么 $dp[1] = flow[1]$。

$flow$ 的转移是显然的，对于一条从 $u \to v$ 的边，如果 $v$ 是叶子结点，那么直接将边权 $w$ 加入 $flow[u]$ 即可；而如果 $v$ 不是叶子结点，那么从 $v$ 到 $u$ 的流量为 $flow[v]$ ，而边上的限制为 $w$ ，所以 $flow[u]$ 要加的应该是 $min(flow[v],w)$ 。

然后考虑换根逻辑。假设我们现在已经知道了 $dp[1]$ 的答案。

那么对于一条从 $u\to v$ 的边，应该如何转移呢，我们以下图为例。

![](https://raw.githubusercontent.com/unicornshjl/MyPic/img/test/9f98bb3b968be41ee1d09580de7fb20d.jpg)

首先绿色部分为流向 $1$ 的答案。我们假设当前根从 $a$ 转移到 $b$ ，那么显然 $b$ 的答案由黄色的三部分所构成。

显然黄色的三部分，实际上可以视作两部分：第一部分为 $b$ 的子树流向 $b$ ，第二部分为从 $a$ 流向 $b$ 。第一部分的答案实际上就是 $flow[b]$ ，我们重点考虑如何求从 $a$ 流向 $b$ 的流量。

从 $a$ 到 $b$ 的流量，能流过来的部分为 $a$ 除了 $b$ 子树外的所有流量，即为 $flow[a] - min(flow[b],w_{a \to b})$ （其中 $min(flow[b],w_{a \to b})$  即为 $b$ 子树向 $a$ 贡献的流量）。

然后其还会受到 $a \to b$ 这条边的约束，所以 $a$ 流向 $b$ 的流量是 $min(flow[a]-min(flow[b],w_{a \to b}),w_{a\to b})$ 。

由此可以推广到 $u$ 转移到 $v$ 的情况，即 $dp[v] = flow[v] + min(flow[u] - min(flow[v],w_{a\to b}),w_{a\to b})$。

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;


constexpr int maxn = 4e5 + 10;
constexpr int N = 20;
int n, to[maxn], nxt[maxn], head[maxn], val[maxn], cnt, d[maxn];
ll flow[maxn], dp[maxn];

void add(int u, int v, int w) {
    to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; val[cnt] = w;
    d[v]++;
}

void dfs1(int u, int fa) {
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];ll w = val[i];
        if (v == fa) continue;
        dfs1(v, u);
        if (d[v] == 1) flow[u] += w;
        else flow[u] += min(flow[v], w);
    }
}

void dfs2(int u, int fa) {
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i]; ll w = val[i];
        if (v == fa) continue;
        if (d[u] == 1)
            dp[v] = flow[v] + w;
        else {
            dp[v] = flow[v] + min(w, dp[u] - min(w, flow[v]));
        }
        dfs2(v, u);
    }
}

void solve() {
    cin >> n;
    cnt = 0;
    for (int i = 1; i <= n; i++)
        d[i] = head[i] = dp[i] = flow[i] = 0;
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w); add(v, u, w);
    }
    dfs1(1, 0);
    dp[1] = flow[1];
    dfs2(1, 0);
    ll MAX = -1;
    for (int i = 1; i <= n; i++)
        MAX = max(MAX, dp[i]);
    cout << MAX << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```
