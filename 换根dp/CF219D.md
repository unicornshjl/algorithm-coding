
看到选择根让代价最小，容易想到是换根 $DP$ 。

状态也非常好设定 我们设 $dp[u]$ 表示以 $u$ 为根的代价。

那么考虑换根逻辑如何设计。

![](https://raw.githubusercontent.com/unicornshjl/MyPic/img/test/e1c5fc12de9f4469839436295909b0e7.jpg)

以上图为例，假设我们已经知道了 $dp_1$ 的值，为 $2$。需要翻转的边已经用黄色标注出来了。

有一个重要结论：**当转移到子节点时，我们只需要考虑其到子节点这一条边的方向即可。**

以上图为例说明这个结论， 以 $1$ 为根时所有边的方向全都背离 $1$ 。由于 $2$ 是 $1$ 的子节点，所以 $2$ 的子树内所有的边全都背离 $2$。

而不是 $2$ 的子树的点全都背离了 $1，1$ 正是 $2$ 作为根时的一棵子树，意味着 $1$ 子树内的所有点全都背离了 $2$ 。

所以我们只需要考虑父节点到子节点的这一条边即可。

考虑转移到 $2$ 和转移到 $5$ 两种情况：

- 转移到 $5$ 。发现 $1$ 到 $5$ 的边指向了 $5$ 。所以这条边在 $1$ 为根时有 $1$ 的代价而现在没有，即这种情况下 $dp_v = dp_u - 1$ 。
- 转移到 $2$ 。发现 $1$ 到 $5$ 的边指向了 $1$ 。所以这条边在 $1$ 为根时没有代价而现在有 $1$ ，所以这种情况下 $dp_v = dp_u + 1$。

那么我们就需要得到每条边的朝向，以及 $1$ 的答案。

题目中以单向边的形式给出边表示方向，那么我们可以建立双向边，和原图一致方向的边边权记为 $0$ ，和原图方向相反的边边权记为 $1$ 。

那么考虑第一次 $dfs$ 过程中如何得到 $1$ 的答案，我们可以用一个 $sum$ 数组来表示 $u$ 作为根时，子树内的答案是多少。

对于一条边 $u\to v$ ，在不考虑 $u$ 到 $v$ 的情况下，显然我们有 $sum_u = \sum sum_v。$

然后我们考虑 $u$ 到 $v$ ，假设 $u$ 到 $v$ 的边权为 $1$ ，则表明原图中的方向是 $v\to u$ 所以应该让 $sum_u+1。$

换根时，对于一条边 $u \to v$ ，如果它的边权为 $0$ 则表明边的方向正是 $u \to v$ 否则表明方向为反向，按照上述换根逻辑转移即可。

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;


constexpr int maxn = 1e6 + 10;

int n;
ll sum[maxn], dp[maxn];

vector<pair<int, int>> edge[maxn];

void add(int u, int v, int w) {
    edge[u].push_back({ v,w });
}

void dfs1(int u, int fa) {
    for (auto [v, w] : edge[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        sum[u] += sum[v];
        if (w == 1)
            sum[u]++;
    }
}

void dfs2(int u, int fa) {
    for (auto [v, w] : edge[u]) {
        if (v == fa) continue;
        if (w == 0) dp[v] = dp[u] + 1;
        else dp[v] = dp[u] - 1;
        dfs2(v, u);
    }
}

void solve() {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v, 0); add(v, u, 1);
    }
    dfs1(1, 0);
    dp[1] = sum[1];
    dfs2(1, 0);
    ll MIN = inf;
    for (int i = 1; i <= n; i++)
        MIN = min(MIN, dp[i]);
    cout << MIN << "\n";
    for (int i = 1; i <= n; i++)
        if (MIN == dp[i])
            cout << i << " ";
    cout << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    solve();
    return 0;
}
```
