## 🌳 换根 DP (Rerooting DP) 的原理与实现

换根 DP，亦称 "二次扫描"，是一种用于解决特定树形问题的动态规划技巧。这类问题通常要求对树中的每一个结点，都计算出当其作为根结点时的某一特定答案。

朴素解法:

最直接的方法是遍历 $N$ 个结点，依次将每个结点设为根，然后执行一次 $O(N)$ 的树形 DP 或 DFS 来求解。然而这种方法的时间复杂度过大，显然无法接受。

换根 DP 优化:

换根 DP 利用两次 DFS 过程，将时间复杂度优化到 $O(N)。$其核心思想在于，当根结点从父结点 $u$ 移动到其子结点 $v$ 时，树的结构仅发生局部变化。因此，当我们已知结点 $u$ 作为根的答案时，结点 $v$ 作为根的答案，可以在先前的基础上，通过 $O(1)$ 或 $O(log N)$ 的代价快速推导出来。

该算法的实现大致分为两个阶段:

#### 阶段一: 第一次 DFS (自底向上, 收集子树信息)

- **目的:** 预处理信息。
- **过程:**
  1. 我们不妨选择 $1$ 作为根。
  1. 执行一次自底向上的 DFS。
  1. 在此过程中，计算每个点的信息，题目不同收集的必要信息不同。
  1. 同时，计算出以结点 1 为根时的最终答案。
- **关键:** 阶段一收集的信息必须能够使得其在阶段二中支持快速的答案转移。

#### 阶段二: 第二次 DFS (自顶向下, 转移全局答案)

- **目的:** 计算所有结点作为根时的最终答案。
- **过程:**
  1. 从 $1$ 开始，执行一次自顶向下的 DFS。
  1. 当从父结点 $u$ 访问子结点 $v$ 时$，v$ 作为根的答案 $ans_v$ 可以通过 $ans_u$ 推导得出。
  1. **(核心转移)** 根从 $u$ 变为 $v$ 时, $v$ 的 "上方"（即结点 $u$ 和它的父结点、其他子树）均成为了 $v$ 的 "下方" 贡献。
     - 转移过程通常需要 "去除" $v$ 子树对 $u$ 的贡献。
     - 然后 "加入" $u$ 结点 (携带其 "上方" 和 "兄弟子树" 的信息) 对 $v$ 的贡献。
