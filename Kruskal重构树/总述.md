

## 🌳 Kruskal 重构树 (Kruskal Reconstruction Tree) 学习笔记



### 1. 核心定义 (Definition)

Kruskal 重构树 (KRT) 是一种基于 Kruskal 最小生成树算法思想构建的数据结构.

构建 KRT 的核心目的. 是将一个图上**两个节点之间所有路径的"瓶颈"信息** (例如路径上最大边权的最小值). 转化(query)为树上**两个节点LCA (最近公共祖先) 的点权**.

通过引入"虚拟节点". 原图中的**边权**被转化成了新树中的**点权**. 这种方法将一个图上的路径问题 (Path Problem) 转化为了一个树上祖先/子树问题 (Tree Problem).

### 2. 构建算法 (Construction Algorithm)

KRT 的构建过程与 Kruskal 算法求 MST 的过程几乎一致. 假设需要解决**最小化路径上最大边权** (Min-Max) 的问题:

1. **初始化 (Initialization):**
   - 原图的 $n$ 个节点. 每个节点视为一个单独的集合 (初始化并查集 DSU).
   - 准备一个节点计数器. `node_count = n`.
   - 原图的 $n$ 个节点将作为 KRT 的**叶子节点**.
2. **排序 (Sort):**
   - 将原图的所有 $m$ 条边 $(u, v, w)$ 按照边权 $w$ **从小到大**排序.
3. **迭代与合并 (Iterate and Merge):**
   - 遍历排序后的边 $(u, v, w)$:
   - 找到 $u$ 和 $v$ 在并查集中的根节点 `root_u` 和 `root_v`.
   - **If `root_u != root_v`:** (即 $u$ 和 $v$ 尚未连通)
     - **创建新节点 (Create Node):** 创建一个全新的**虚拟节点** $p$. 编号为 `p = ++node_count`.
     - **赋点权 (Assign Weight):** 将这个新节点 $p$ 的**点权**设置为当前边的边权 $w$. (即 `weight[p] = w`).
     - **连接树 (Build Tree):** 在 KRT 中. 将 $p$ 作为 `root_u` 和 `root_v` 的**父节点**. (即 `parent[root_u] = p`, `parent[root_v] = p`).
     - **合并集合 (Merge DSU):** 在并查集中. 将 `root_u` 和 `root_v` 所代表的集合合并. 并将新的根设置为 $p$. (即 `dsu_parent[root_u] = p`, `dsu_parent[root_v] = p`).
4. **完成 (Finalize):**
   - 所有边处理完毕后. 如果原图是连通的. 会得到一棵包含 $2n - 1$ 个节点 ( $n$ 个叶子. $n-1$ 个内部节点) 的树.
   - 如果原图不连通. 会得到一个森林 (Forest).

### 3. 核心性质 (Core Properties)

这棵构建出来的新树具有一些至关重要的性质:

1. **二叉树结构 (Binary Tree):** 每个非叶子节点 (虚拟节点) 都有两个子节点. 整个结构是一棵二叉树.
2. **叶子节点 (Leaves):** 所有的**叶子节点**都是原图中的 $n$ 个节点. 所有的**内部节点** (Internal Nodes) 都是构建时新加的虚拟节点.
3. **堆性质 (Heap Property):**
   - 如果按边权**从小到大**构建 (Min-Max 型). 那么从根节点到任意叶子节点的路径上. **点权单调递增**. (父节点的点权 $\ge$ 子节点的点权. 类似小根堆)
   - 如果按边权**从大到小**构建 (Max-Min 型). 那么**点权单调递减**. (父节点的点权 $\le$ 子节点的点权. 类似大根堆)
4. **LCA 的意义 (The Magic of LCA):**
   - 在**从小到大**构建的 KRT 中. 原图中两个节点 $u$ 和 $v$ 之间的**所有**路径中. "路径最大边权" 的**最小值**. 等于 KRT 上 $u$ 和 $v$ 的 $LCA(u, v)$ 的**点权**.
   - (这正是 $u, v$ 在原图最小生成树上的路径的最大边权).
5. **子树的意义 (Subtree Property):**
   - 在**从小到大**构建的 KRT 中. 对于任意一个虚拟节点 $p$ (点权为 $w$). **$p$ 的子树中包含的所有叶子节点**. 恰好是原图中一个"连通块"的**点集**.
   - 在这个连通块中. 任意两个节点都可以**只通过边权 $\le w$ 的边**互相到达.



### 4. 主要应用 (Applications)

KRT 主要用于解决两类"瓶颈"问题. 以及相关的连通性查询.

#### (1) 最小化最大边权 (Min-Max Bottleneck)

- **问题:** 查询 $u$ 到 $v$ 的所有路径中. 使得路径上的**最大边权**最小.
- **构建:** 按边权**从小到大**排序构建 KRT.
- **查询:** 答案就是 KRT 上 $LCA(u, v)$ 的点权.
- **(这对应了最初笔记中的核心思想)**

#### (2) 最大化最小边权 (Max-Min Bottleneck)

- **问题:** 查询 $u$ 到 $v$ 的所有路径中. 使得路径上的**最小边权**最大.
- **构建:** 按边权**从大到小**排序构建 KRT.
- **查询:** 答案就是 KRT 上 $LCA(u, v)$ 的点权.

#### (3) K 阈值连通性 (K-Threshold Connectivity)

- **问题:** 查询从节点 $u$ 出发. 只经过边权 $\le k$ 的边. 能够到达的所有节点.
- **构建:** 按边权**从小到大**排序构建 KRT.
- **查询:**
  1. 在 KRT 上. 从叶子节点 $u$ 向上"倍增" (Binary Lifting). 找到 $u$ 的一个最浅的祖先 $p$. 满足 `weight[p] <= k`.
  2. 根据"堆性质". $p$ 的子树中所有节点的点权都 $\le k$.
  3. **答案:** $p$ 的子树中包含的**所有叶子节点**的**集合**. (这个集合可以通过预处理 DFS 序. 用 $O(1)$ 的 $Size[p]$ 来获取. 或者用 $in[p]$ 和 $out[p]$ 序列来表示).

### 5. 实现细节 (Implementation Details)

- **节点总数:** KRT 最多有 $2n-1$ 个节点. 所有数组 (并查集, 树的邻接表, LCA 倍增数组) 都必须开到 **2N** 的大小.
- **并查集 (DSU):** `Find` 函数在构建时是必要的. 它的 `parent` 数组需要能同时指向原节点 ( $1$ 到 $n$ ) 和虚拟节点 ( $n+1$ 到 $2n-1$ ).
- **LCA:** 构建完 KRT 后. 需要一次 DFS 预处理出 `depth`, `size` 以及 `fa[i][j]` (倍增数组). 以便 $O(\log N)$ 回答 $LCA$ 查询.
- **存图:** KRT 本身是一棵树 (或森林). 需要一个**新的邻接表** `G_krt` 来存储 KRT 的结构 (即 $p$ 指向 `root_u` 和 `root_v` 的边).
-  **注意:** 原图 `G_original` 只需用来读入边. 之后只使用 KRT.

