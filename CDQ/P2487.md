
首先我们考虑哪些导弹有可能会被拦截 一定是那些在"最长路"上的导弹节点

具体地说 我们用 $L[i]$ 表示以 $i$ 结尾的最多拦截导弹数目 用 $R[i]$ 表示以 $i$ 开始的最多拦截导弹数目

取 $MAX = \max(L[i]),i\in(1,n)$ 

如果 $L[i] + R[i] - 1 == MAX$ 那么则表明导弹 $i$ 一定会被拦截

其被拦截的概率 $P=\frac{包含 i 的方案数}{总方案数}$ 

如果我们记 $l[i]$ 为以 $i$ 结尾的拦截最多导弹数目的方案数 用 $r[i]$ 表示以 $i$ 开始的最多拦截导弹数目的方案数

同时记录 $L[i] = MAX$ 的 $i$ 对应的方案数 $l[i]$ 总和 $sum$

那么 $P = \frac{l[i]\times r[i]}{sum} $ 即可求出概率

于是问题变为了 如何处理 $L[i]$ 和 $l[i]$ 以及 $R[i]$ 和 $r[i]$

我们先考虑 $L[i]$ 和 $l[i]$ 如何处理 因为 $R[i]$ 和 $r[i]$ 可以通过将序列翻转后重新进行一遍求 $L$ 的过程即可

求 $L$ 的过程 实际上就是一个求解**三维偏序 $DP$ 的过程** 这需要用 **$CDQ$ 分治**

因为如果 $j$ 能够拦截 $i$ 要满足 $i<j$ 且 $h[i] < h[j]$ 且 $v[i] < v[j]$

那么我们按照 $i$ 从小到大排序 当然实际上这并不需要

然后我们开始讲解 $CDQ$ 分治优化 $DP$ 的过程

本质上 就是利用了归并分治 优化 树状数组优化 $DP$

首先 传统的 $CDQ$ 分治的过程是

```cpp
CDQ(l,mid);
CDQ(mid + 1, r);
merge(l,r);
```

然而 由于 $DP$ 过程中 编号靠后的状态依赖于编号靠前的状态 所以我们需要对这个过程进行修改 一般地 我们要修改成

```cpp
CDQ(l,mid);
merge(l,r);
CDQ(mid + 1, r);
```

第二维 我们按照 $h$ 数组从小到大排序 然后我们仍然按照 $CDQ$ 分治的策略 移动双指针 不断地将信息加入树状数组即可

但是由于树状数组只能维护前缀的最大值 而我们要求的是 $v[j] > v[i]$ 那么我们就直接让查询和放入的值直接变成 $v_{max} - v[i] + 1$ 即可 这样原本的 $>$ 号就成功的变为了我们所希望的 $<$ 

我们考虑如何维护最大值以及最大值出现的次数

首先初始化 $DP$ 数组上 每个点本身的长度就为 $1$ 且方案数为 $1$ 而树状数组中我们要把最大值设为 $-1$ 且方案数设为 $0$ 以便后续正确更新

更新树状数组和 $DP$ 数组中值的时候 每次更新的时候 如果当前值 $>$ 之前最大值 那么就成为新的最大值且方案数继承之 ，否则如果当前值 $=$ 之前最大值 那么方案数就 $+$ 当前的方案数即可

需要注意的是做完该过程之后 要将树状数组中的值全部清空 以免影响下一次

然后考虑 $R$ 如何得到 首先我们要翻转整个数组 也就是 $a_{i}$ 变为 $a_{n - i+ 1}$

这还不够 $R$ 是以 $i$ 为起点的最长序列 $i$ 是整个序列中的最小值 **这是与 $L$ 正好相反的** 所以我们要将 $v$ 和 $h$ 的值全部翻转 然后再进行 $DP$



代码如下 $: $



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

constexpr int maxn = 1e6 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };

int n, c[maxn], len, L[maxn], R[maxn];
ld l[maxn], r[maxn];

struct node {
    int h, v, id;
} a[maxn], b[maxn];

struct T {
    int len; ld sum;
} tr[maxn], ans[maxn];

bool cmp(node c1, node c2) {
    return c1.h > c2.h;
}

void add(int x, int y,ld z) {
    for (int i = x; i <= len; i += lowbit(i))
        if (y > tr[i].len) tr[i].len = y, tr[i].sum = z;
        else if (y == tr[i].len) tr[i].sum += z;
}

T query(int x) {
    T res = { 0,0 };
    for (int i = x; i >= 1; i -= lowbit(i))
        if (tr[i].len > res.len)
            res = tr[i];
        else if (tr[i].len == res.len) res.sum += tr[i].sum;
    return res;
}

void clear(int x) {
    for (int i = x; i <= len; i += lowbit(i))
        tr[i] = { -1,0 };
}

void merge(int l, int r) {
    for (int i = l; i <= r; i++)
        b[i] = a[i];
    int mid = (l + r) / 2;
    sort(b + l, b + mid + 1, cmp);
    sort(b + mid + 1, b + r + 1, cmp);
    int i = l;
    vector<int> tmp;
    for (int j = mid + 1; j <= r; j++) {
        while (i <= mid && b[i].h >= b[j].h) {
            add(len + 1 - b[i].v, ans[b[i].id].len, ans[b[i].id].sum);
            tmp.push_back(len + 1 - b[i].v);
            i++;
        }
        T cur = query(len + 1 - b[j].v);
        if (cur.len + 1 > ans[b[j].id].len) {
            ans[b[j].id].len = cur.len + 1;
            ans[b[j].id].sum = cur.sum;
        }
        else if (cur.len + 1 == ans[b[j].id].len)
            ans[b[j].id].sum += cur.sum;
    }
    for (auto v : tmp)
        clear(v);
}

void CDQ(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    CDQ(l, mid);
    merge(l, r);
    CDQ(mid + 1, r);
}

void disc() {
    for (int i = 1; i <= n; i++)
        c[i] = a[i].v;
    sort(c + 1, c + n + 1);
    len = unique(c + 1, c + n + 1) - c - 1;
    for (int i = 1; i <= n; i++)
        a[i].v = lower_bound(c + 1, c + len + 1, a[i].v) - c;
}

void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].h >> a[i].v;
        a[i].id = i;
    }
    for (int i = 1; i <= n; i++)
        ans[i] = { 1,1 };
    disc();
    for (int i = 1; i <= len; i++)
        tr[i] = { -1,0 };
    CDQ(1, n);
    for (int i = 1; i <= n; i++)
        L[i] = ans[i].len, l[i] = ans[i].sum;
    for (int i = 1; i <= n / 2; i++)
        swap(a[i], a[n + 1 - i]);
    for (int i = 1; i <= n; i++)
        a[i].v = len + 1 - a[i].v, a[i].h = 1000000000 - a[i].h;
    for (int i = 1; i <= n; i++)
        ans[i] = { 1,1 };
    CDQ(1, n);
    for (int i = 1; i <= n; i++)
        R[i] = ans[i].len, r[i] = ans[i].sum;
    ld sum = 0;
    int MAX = 0;
    for (int i = 1; i <= n; i++)
        MAX = max(MAX, L[i]);
    cout << MAX << "\n";
    for (int i = 1; i <= n; i++)
        if (MAX == L[i]) sum += l[i];
    for (int i = 1; i <= n; i++)
        if (L[i] + R[i] - 1 == MAX) {
            ld p = l[i];
            ld q = r[i];
            ld res = p * q / sum;
            cout << res << " ";
        }
        else cout << 0 << " ";
    cout << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //prework();
    //cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

