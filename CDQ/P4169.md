$P4169 : $

首先我们观察式子 $dist = |A_x - B_x| + |A_y - B_y|$

有绝对值很不好处理 我们先考虑其的一个子问题

也就是考虑先去掉绝对值 也就是先假定 $A_x \ge B_x$ 且 $A_y \ge B_y$

那么 $dist = A_x - B_x + A_y - B_y = A_x + A_y - (B_x + B_y) $ 

那么我们就可以对于一个点 去统计 $x\le X_i$ 且 $y\le Y_i$ 中 $x+y$ 的最大值 用 $X_i+Y_i - (x+y)$ 计算出当前的最佳贡献

然后再整体求一个最小值即可

那么这个子问题就转换成了 先后顺序(**时间戳**) 横坐标 $X$ 纵坐标 $Y$ 求范围最大值的问题

可以很容易的用 $CDQ$ 分治解决 

还是按照 $Time$ 为第一关键字  $X$ 为第二关键字 用树状数组处理 $Y$ 维护最大值即可

由于这个子问题和 $P4390$ 相当类似 不再赘述

然后我们考虑有绝对值应该怎么办

也就是剩下的三种情况

-  $A_x \le B_x$ 且 $A_y \ge B_y$
-  $A_x \ge B_x$ 且 $A_y \le B_y$
-  $A_x \le B_x$ 且 $A_y \le B_y$

我们可以考虑让**点对称**  什么意思呢 $?$

比如考虑计算 $A_x \le B_x$ 且 $A_y \ge B_y$ 就是我们让所有的点 $x$ 坐标关于 $y$ 轴对称 

那么原来的 $A_x \le B_x$ 的 对称之后就变成了 $A_x \ge B_x$ 也就转换为了我们讨论过的子问题

那么余下两种情况分别让 $y$ 坐标 关于 $x$ 轴点对称 和 让点关于原点中心对称 就可以转化为初始的子问题

但是关于轴对称和原点对称会让坐标出现负数值 这是我们在树状数组中无法接受的

那么我们就让 $x$ ( $y$ 同理) 变为 $M - x$ 即可 (其中 $M = max +1$)  $max$ 为所有输入的 $x$ 和 $y$ 的最大值

于是整个问题迎刃而解 同时需要使用上一题所说的方法来避免树状数组出现 $0$ 下标



代码如下 $: $

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

constexpr int maxn = 1e6 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };

int n, m, cnt, M, tr[maxn], ans[maxn];

struct node {
    int x, y, id, op;
} a[maxn], b[maxn];

void Add(int x, int y,int op) {
    cnt++; 
    a[cnt].x = x; a[cnt].y = y; a[cnt].op = op;
}

void add(int x, int y) {
    for (int i = x; i <= M; i += lowbit(i))
        tr[i] = max(tr[i], y);
}

int query(int x) {
    int res = -10000000;
    for (int i = x; i >= 1; i -= lowbit(i))
        res = max(res, tr[i]);
    return res;
}

void clear(int x) {
    for (int i = x; i <= M; i += lowbit(i))
        tr[i] = -10000000;
}

bool cmp(node c1, node c2) {
    return c1.x < c2.x;
}

void merge(int l, int r) {
    int mid = (l + r) / 2;
    int i = l;
    vector<int> tmp;
    for (int j = mid + 1; j <= r; j++) {
        while (i <= mid && b[i].x <= b[j].x) {
            if (b[i].op == 0) {
                add(b[i].y, b[i].x + b[i].y);
                tmp.push_back(i);
            }
            i++;
        }
        if (b[j].op == 1)
            ans[b[j].id] = min(ans[b[j].id], b[j].x + b[j].y - query(b[j].y));
    }
    for (auto p : tmp)
        clear(b[p].y);
    sort(b + l, b + r + 1, cmp);
}

void CDQ(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    CDQ(l, mid);
    CDQ(mid + 1, r);
    merge(l, r);
}

void doit(int d) {
    for (int i = 1; i <= M; i++)
        tr[i] = -10000000;
    for (int i = 1; i <= cnt; i++) {
        b[i] = a[i];
        if (d == 2 || d == 4) b[i].x = M - b[i].x;
        if (d == 3 || d == 4) b[i].y = M - b[i].y;
    }
    CDQ(1, cnt);
}

void solve() {
    cin >> n >> m;
    int num = 0;
    for (int i = 1; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        x++; y++;
        M = max({ M,x,y });
        Add(x, y, 0);
    }
    for (int i = 1; i <= m; i++) {
        int op, x, y; 
        cin >> op >> x >> y;
        x++; y++; op--;
        M = max({ M,x,y });
        if (op == 0) {
            Add(x, y, op);
        }
        else {
            num++;
            Add(x, y, op);
            a[cnt].id = num;
        }
    }
    for (int i = 1; i <= num; i++)
        ans[i] = 10000000;
    M++;
    doit(1);
    doit(2);
    doit(3);
    doit(4);
    for (int i = 1; i <= num; i++)
        cout << ans[i] << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```



