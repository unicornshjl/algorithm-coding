题目中有用的只有两种操作

- $x$ $y$ $a$ 向 $x,y$ 上的权值 $+a$
- $x_1$ $y_1$ $x_2$ $y_2$ 查询以 $x_1,y_1$ 为左下角 $x_2,y_2$ 为右上角的正方形内部的权值总和

查询操作容易想到二维前缀和 我们假设 $f[x,y]$ 表示从 $1,1$ 到 $x,y$ 内部权值总和

那么询问的答案显然为 $f[x_2,y_2] - f[x_1 - 1,y2] - f[x_2,y_1 - 1] + f[x_1 - 1,y_1 - 1]$ 

如果 $x,y$ 的范围较小的话 我们可以直接用二维树状数组解决本题 然而题目中的 $w\le2\times10^6$ 显然是无法使用二维树状数组的

由于操作涉及到先后顺序(**时间戳**)  横坐标 $x$ 和纵坐标 $y$ 三个维度的偏序关系

那么我们考虑用 $CDQ$ 分治来解决这个问题

首先我们一定是按照**时间戳**排序的 因为要按照顺序依次执行每个操作

然后因为我们要去找 $\le x_j$ $\le y_j$ 的权值和 

所以我们可以**以 $x$ 为第二维**进行排序  用树状数组去统计 $\le y_j$ 的权值总和

细节上 我们需要把每一次添加操作视作一个 $op = 0$ 的操作 表示它并非某次查询的一部分 无须贡献答案

而我们需要把每次查询操作拆分成四个操作 其中 $x_2,y_2$ 和 $x_1 - 1,y_1 - 1$ 操作的 $op = 1$ 表明这次查询对答案的贡献是正的

$x_1,y_2 - 1$ 和 $x_2, y_1 - 1$ 操作的 $op = -1$ 表明这次查询对答案的贡献是负的

同时我们需要对每个查询操作记录 $id$ 表示它是对哪一次查询进行的贡献

还需要注意的是 由于 $x$ 和 $y$ 的值 $-1$ 过后可能会出现 $0$ 

但是树状数组的下标一般不允许 $0$ 的出现 所以我们把所有输入的 $x$ 和 $y$ 以及矩形大小 $w$ 先进行 $ +1$ 处理 来避免 $0$ 下标的出现



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;

constexpr int maxn = 2e6 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };

ll tr[maxn], ans[maxn];
int w, cnt;

struct node {
    int op, x, y, id, val;
} a[maxn];

ll query(int x) {
    ll res = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        res += tr[i];
    return res;
}

void add(int x, ll y) {
    for (int i = x; i <= w; i += lowbit(i)) 
        tr[i] += y;
}

void addnew(int op, int x, int y, int num) {
    cnt++;
    a[cnt].op = op; a[cnt].x = x; a[cnt].y = y;a[cnt].id = num;
}

bool cmp(node c1, node c2) {
    if (c1.x == c2.x) {
        return c1.op < c2.op;
    }
    return c1.x < c2.x;
}

void merge(int l, int r) {
    int mid = (l + r) / 2;
    int i = l;
    vector<int> tmp;
    for (int j = mid + 1; j <= r; j++) {
        while (i <= mid && a[i].x <= a[j].x) {
            if (a[i].op == 0) {
                add(a[i].y, a[i].val);
                tmp.push_back(i);
            }
            i++;
        }
        if (a[j].op != 0) {
            ll cur = (a[j].op == 1 ? 1 : -1);
            ans[a[j].id] += cur * query(a[j].y);
        }
    }
    for (auto p : tmp)
        add(a[p].y, -a[p].val);
    sort(a + l, a + r + 1, cmp);
}

void CDQ(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    CDQ(l, mid);
    CDQ(mid + 1, r);
    merge(l, r);
}

void solve() {
    int op;
    cin >> op;
    int num = 0;
    while (op != 3) {
        if (op == 0) cin >> w;
        if (op == 1) {
            int x, y, z;
            cin >> x >> y >> z;
            x++; y++;
            addnew(0, x, y);
            a[cnt].val = z;
        }
        if (op == 2){
            int xa, xb, ya, yb;
            num++;
            cin >> xa >> ya >> xb >> yb;
            xa++; ya++; xb++; yb++;
            addnew(1, xb, yb, num);
            addnew(2, xa - 1, yb, num);
            addnew(2, xb, ya - 1, num);
            addnew(1, xa - 1, ya - 1, num); 
        }
        cin >> op;
    }
    w++;
    CDQ(1, cnt);
    for (int i = 1; i <= num; i++)
        cout << ans[i] << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```

