### 1. 核心思想 (Core Idea)

整体二分, 顾名思义, 它并不是对单个询问进行二分答案, 而是**将所有询问"打包"在一起**, 共同对"**答案的值域**"进行二分.

它是一种**分治** (Divide and Conquer) 算法. 在分治的每一层, 我们尝试将所有待处理的询问划分为两个部分: 一部分询问的答案**小于等于**当前二分的 $mid$, 另一部分则**大于** $mid$. 最终, 当答案区间 $[ans\_l, ans\_r]$ 缩小到 $ans\_l = ans\_r$ 时, 我们就找到了该区间内所有询问的共同答案.

### 2. 适用场景 (Prerequisites)

要使用整体二分, 题目通常需要满足以下条件:

- **询问离线 (Offline):** 整体二分算法不支持强制在线的查询.
- **答案单调性 (Monotonicity):**
  - 单个询问的答案必须具有单调性, 这样才能对其进行二分. (例如: 询问 "第 $k$ 小", "最早在什么时刻满足条件" 等).
- **可批量处理 (Batch Processing):**
  - 题目中的"修改" (Operations) 和 "询问" (Queries) 必须可以被分离.
  - 修改操作对询问结果的贡献必须是可叠加的, 并且这种贡献**与询问的顺序无关**.
- **贡献可拆分 (Divisible Contribution):**
  - 一个修改操作对一个询问的贡献, 可以被高效地计算.
  - (例如: 我们可以快速计算所有"值" $\le mid$ 的修改操作对当前询问集合的影响).

### 3. 算法流程 (Algorithm Flow)

我们通常定义一个递归函数 `solve(ql, qr, cl, cr)`:

> 函数定义:
>
> 当前处理的询问在原序列中的编号区间为 $[q\_l, q\_r]$.
>
> 我们猜测这些询问的答案在值域区间 $[c\_l, c\_r]$ 之内.

------

**递归过程:**

**Step $1$: 递归出口 (Base Case)**

- 如果 $c\_l = c\_r$, 意味着我们已经找到了答案.
- 此时, 将所有在 $[q\_l, q\_r]$ 范围内的询问的答案全部标记为 $c\_l$ 
- 返回 (`return`).

**Step $2$: 检查是否无解**

- 如果 $q\_l > q\_r$, 意味着当前没有任何询问需要处理, 直接返回.

**Step $3$: 分治 (Divide)**

- 计算答案的中点: $mid = (c\_l + c\_r) / 2$.
- 我们的目标是:
  - 将 $[q\_l, q\_r]$ 内的询问分为 "答案 $\le c\_mid$" (左组) 和 "答案 $> c\_mid$" (右组).
  - 将与这些询问相关的**修改操作**也分为 "对 $mid$ 判断有贡献" (左组) 和 "对 $mid$ 判断无贡献" (右组).

**Step $4$: 处理与判定 (Process & Check)**

- **遍历操作:** 遍历当前处理的所有操作 (包括修改和询问).
  - **对于修改操作:** 如果该修改操作的"值" (例如: 插入的数, 修改发生的时间) $\le mid$, 那么它是一个**"有效修改"**. 我们将其"生效", 例如, 在一个**辅助数据结构** (如树状数组) 中更新它的贡献.
  - **对于询问操作:** 在所有"有效修改"都生效后, 我们检查这个询问的条件是否**已经满足**.
    - (例如: 询问第 $k$ 小. 我们就在树状数组中查询 $\le mid$ 的数有多少个 记为 $count$)
- **分组 (Partition):**
  - **清空辅助数据结构:** 在判定完所有询问后, **必须撤销**所有刚才"生效"的修改操作 (例如: 在树状数组中减去对应的贡献). 这是至关重要的一步, 确保右侧递归的纯洁性.
  - **分流:**
    - 将所有 "值" $\le mid$ 的**修改操作**放入 "左操作组".
    - 将所有 "值" $> mid$ 的**修改操作**放入 "右操作组".
    - 对于**询问操作**:
      - 如果刚才检查时条件**已满足** (例如: $count \ge k$): 说明它的答案 $\le mid$. 将其放入 "左询问组".
      - 如果条件**未满足** (例如: $count < k$): 说明它的答案 $> ans\_mid$. 将其放入 "右询问组". 并且, **需要更新该询问的参数** (例如在询问区间第 $k$ 小时 : $k = k - count$, 因为我们已经确定有 $count$ 个数比它的答案小).

**Step $5$: 递归 (Conquer)**

- **递归左侧:** `solve(左询问组, cl, mid)`
  - (注意: 左操作组也需要被传入, 以便在下一层递归中继续被划分)
- **递归右侧:** `solve(右询问组, mid + 1, cr)`
  - (注意: 右操作组也需要被传入)

### 4. 关键实现细节 (Implementation Details)

- **辅助数据结构:**
  - 在 Step $4$ 中, "让操作生效" 和 "检查询问是否满足" 这两步, 几乎总伴随着一个高效的数据结构.
  - 最常用的是 **树状数组 (BIT)** 或 **线段树 (Segment Tree)**.
  - 例如, 在 "**区间第 $k$ 小**" 问题中, 我们用树状数组维护权值 (值域), "修改" 对应单点加, "询问" 对应前缀和查询.
- **操作的撤销 (Undo):**
  - 如 Step $4$ 所述, 在递归进入右侧子问题 (Step $5$) 之前, **必须**将所有对 $mid$ 产生贡献的操作 (即 $\le ans\_mid$ 的操作) 从辅助数据结构中**清除**.
  - 这是为了防止它们"污染" 对 $> mid$ 的答案的判断.
- **修改与询问的统一:**
  - 为了便于处理, 常常把"修改"和"询问"统一为同一种"操作" (Operation) 结构体, 用一个类型字段 (e.g., `op=1` 为修改, `op=2` 为询问) 来区分. 这样, 递归函数 `work` 就可以统一处理一个 "操作" 数组.

### 5. 复杂度分析 (Complexity Analysis)

- 设 $N$ 为修改操作的总数, $M$ 为询问的总数, $V$ 为答案的值域范围.
- 递归树的深度为 $O(\log V)$ (因为我们二分的是答案的值域).
- 在递归的**每一层**, 我们都需要处理 $N+M$ 个操作.
- 处理每个操作时, 需要在辅助数据结构上进行 $O(T_{ds})$ 的操作 (例如, 树状数组 $T_{ds} = \log N$ 或 $\log V$).
- 因此, 总时间复杂度通常为: $O((N+M) \cdot \log V \cdot T_{ds})$
- 如果使用树状数组, 复杂度为: $O((N+M) \log V \log N)$.



