带单点修改的区间第 $k$ 小问题

静态区间第 $k$ 小我们可以利用整体二分 $+$ 树状数组很好的解决 那么我们考虑采用同样的思想 应该如何处理这个问题

其实本质上就是多了修改操作 那么一次将 $x$ 变为 $y$ 的修改操作应该如何处理呢

事实上 我们可以将这一条操作分为两条操作 

**1.在原位置上删去 $x$** 也就是要在 $x$ 所在位置减少 $1$ 个 $x$ 即在树状数组上让 $x$ 所在位置 $-1$

**2.在原位置上增加 $y$** 也就是要在 $y$ 所在位置增加 $1$ 个 $y$  即在树状数组上让 $y$ 所在位置 $+1$

所以对于原数组中的值我们也可以视作一个增加操作 在 $a_i$ 所在位置增加了一个 $a_i$ 也就是让树状数组上 $a_i$ 对应的位置 $+1$

这一点是和静态区间第 $k$ 小相同的

所以我们就把操作分为了两类

- 询问第 $k$ 小
- 单点修改 (可能 $+1$ 也可能 $ -1$)

那么我们原本整体二分用的区间范围 $[1,n]$ 在本题中不再适用 而是应该使用总操作数 $[1,cnt]$

而答案的范围是多少呢 我们采用偷懒的办法 直接采用值域当做答案的范围

此时我要考虑 假设正在求 $[ql,qr]$ 区间的 而二分的答案为 $mid$ 应该如何处理

首先，我们**只处理所有值 $\le mid$ 的修改操作**

因为我现在二分左组的就是以 $[l,mid]$ 中的数作为第 $k$ 小

显然比 $mid$ 大的元素根本不可能影响 $mid$ 是第几小 所以它们根本不需要在树状数组上进行操作

同时 我们要把值 $>mid$ 的全部放入右组 因为这

而对于查询操作 我们都进行区间查询 由于有 $+1$ 和 $-1$ 两种不同的操作 所以我们查询的是这个区间的**区间和**

如果已经满足了要求 那么就放到左组 否则让 $rank$ 减去当前值后 放到右组

然后按照整体二分的标准做法做即可



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

int lowbit(int x) {
    return x & (-x);
}

constexpr int maxn = 6e5 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };

int n, m, cnt, q[maxn], op[maxn], p[maxn], v[maxn], d[maxn], a[maxn], rk[maxn], L[maxn], R[maxn], number[maxn];
int ans[maxn], tr[maxn], le[maxn], ri[maxn];

void add(int x,int y) {
    for (int i = x; i <= n; i += lowbit(i))
        tr[i] += y;
}

int query(int x) {
    int res = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        res += tr[i];
    return res;
}


void work(int ql, int qr, int cl, int cr) {
    if (ql > qr) return;
    if (cl == cr) {
        for (int i = ql; i <= qr; i++) {
            int num = q[i];
            if (op[num] == 2) ans[number[num]] = cl;
        }
        return;
    }
    int mid = (cl + cr) / 2, lnum = 0, rnum = 0;
    vector<pair<int, int>> tmp;
    for (int i = ql; i <= qr; i++) {
        int num = q[i];
        if (op[num] == 1) {
            if (v[num] <= mid) {
                add(p[num], d[num]);
                tmp.push_back({ p[num], d[num] });
                le[++lnum] = num;
            }
            else 
                ri[++rnum] = num;
        }
        else {
            int cur = query(R[num]) - query(L[num] - 1);
            if (cur >= rk[num]) 
                le[++lnum] = num;
            else {
                rk[num] -= cur;
                ri[++rnum] = num;
            }
        }
    }
    for (auto [v, w] : tmp) add(v, -w);
    for (int i = 1; i <= lnum; i++) q[ql + i - 1] = le[i];
    for (int i = 1; i <= rnum; i++) q[ql + lnum + i - 1] = ri[i];
    work(ql, ql + lnum - 1, cl, mid);
    work(ql + lnum, qr, mid + 1, cr);
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        cnt++;
        q[cnt] = cnt;
        op[cnt] = 1;
        p[cnt] = i;
        v[cnt] = x;
        d[cnt] = 1;
        a[i] = x;
    }
    int num = 0;
    for (int i = 1; i <= m; i++) {
        char c; cin >> c;
        if (c == 'Q') {
            int l, r, x;
            cin >> l >> r >> x;
            cnt++;
            q[cnt] = cnt;
            op[cnt] = 2;
            L[cnt] = l;
            R[cnt] = r;
            rk[cnt] = x;
            number[cnt] = ++num;
        }
        else {
            int x, y;
            cin >> x >> y;
            cnt++;
            q[cnt] = cnt;
            op[cnt] = 1;
            p[cnt] = x;
            v[cnt] = a[x];
            d[cnt] = -1;    
            cnt++; 
            q[cnt] = cnt;
            op[cnt] = 1;
            p[cnt] = x;
            v[cnt] = y;
            d[cnt] = 1;
            a[x] = y;
        }
    }
    work(1, cnt, 0  , intinf);
    for (int i = 1; i <= num; i++)
        cout << ans[i] << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    solve();
    return 0;
}
```

