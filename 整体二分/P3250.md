操作 $1$ 添加一条新的路径

操作 $2$ 撤销一条路径

操作 $3$ 查询未被影响的重要度的最大值

操作 $1$ 和操作 $2$ 是树上常见问题 

我们考虑操作 $3$如何处理

假设未被影响的重要度的最大值为 $v$ 

那么就意味着**一定存在某条边使得其未被影响 且值为 $v$**

直接处理它是困难的 我们考虑**是否所有重要度 $> v$ 的边全都被影响 (*)**

如果否 那么就意味着确实存在 否则就意味着不存在

那么显然这个问题具有单调性 我们可以采用**整体二分**来处理所有询问

根据上述分析 假设当前的答案为 $mid$ 那么如果 **(*)** 为假 

那么表明当前询问应该进入右组 继续排查 $[mid,r]$ 的范围内是否存在答案

否则应该进左组 因为所有边全部被影响了 $mid$ 一定是不符合题意的 根据单调性只能去找 $< mid$ 的值

那么如何判断当点 $u$ 故障时 被影响的边的个数呢

显然被影响的边一定是**还存在**且**经过 $u$ 的边**

此时 我们想到操作 $1$ 和 $2$ 是树上加边删边操作 那么很容易联想到树上点差分

加边操作可以视作让路径上所有点的权全部 $+1$ 删边操作可以视作让路径上所有点全部 $-1$

此时我们就可以利用树上点差分将该问题转化为 $4$ 次单点修改和区间查询问题

这是很容易使用树状数组结合 $dfs$ 序实现的

其中 $4$ 次单点修改是因为点差分的原理 而 区间查询是因为根据点差分原理，我们要查询 $u$ 的子树内部的权值和

那么我们可以很快的得到被影响的边的数目 但是**存在着的边的总数目**如何得到呢

其实是简单的 

由于我们在整体二分的过程中 只让权值 $>mid$ 的边进行操作 而 $\le mid$ 的边直接进入了左组

所以我们可以记录操作的这些边操作的总和 也就是 `sum += op` 其中 `sum` 表示总和 而 `op` 表示当前操作 `-1` 或 `1`

这里的 `sum` 就是存在着的边数

所以当我们碰到询问操作时 如果当前查询出的数目恰好为 `sum` 就表明 **(*)** 为真 进入左组 否则表明为假 进入右组

进行整体二分即可



PS : 此题中用到的点差分原理

让 `u` 到 `v` 的路径 `+w` 那么就是让 `u,v` 节点上的值分别 `+w` 同时让 `LCA(u,v),father of LCA(u,v)` 上的值分别 `-w`

这分别对应了树状数组上的四次单点修改 修改的是 `dfn[x]` 上对应的值

查询经过某点 `u` 的权值 就是查询 `u` 子树上的权值之和
由于子树内部 `dfn` 序号连续 所以查询的就是 `dfn[x]` 到 `dfn[x] + siz[x] - 1` 的区间和 其中 `siz[x]` 表示 `x` 子树的大小



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

int lowbit(int x) {
    return x & (-x);
}

constexpr int maxn = 4e5 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };

int n, m, u[maxn], v[maxn], w[maxn], o[maxn], d[maxn], ans[maxn], q[maxn], f[maxn][N], dep[maxn], L[maxn], R[maxn];
int tr[maxn], dfn[maxn], tim = 1, siz[maxn];

vector<int> edge[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

void Add(int x, int y) {
    if (x == 0) return;
    for (int i = x; i <= n + 1; i += lowbit(i))
        tr[i] += y;
}

int Query(int x) {
    int res = 0;
    for (int i = x; i >= 1; i -= lowbit(i))
        res += tr[i];
    return res;
}

int get_lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int k = dep[u] - dep[v];
    for (int i = N - 1; i >= 0; i--)
        if ((k >> i) & 1) u = f[u][i];
    if (u == v) return u;
    for (int i = N - 1; i >= 0; i--)
        if (f[u][i] != f[v][i])
            u = f[u][i], v = f[v][i];
    return f[u][0];
}

void change(int u, int v, int w) {
    int lca = get_lca(u, v);
    Add(dfn[u], w);
    Add(dfn[v], w);
    Add(dfn[lca], -w);
    Add(dfn[f[lca][0]], -w);
}

void work(int ql, int qr, int cl, int cr) {
    if (ql > qr)
        return;
    if (cl == cr) {
        for (int i = ql; i <= qr; i++) {
            int id = q[i];
            if (o[id]) ans[w[id]] = cl;
        }
        return;
    }
    int mid = (cl + cr) / 2, lnum = 0, rnum = 0, sum = 0;
    vector<int> tmp;
    for (int i = ql; i <= qr; i++) {
        int id = q[i];
        if (o[id] == 0) {
            if (w[id] > mid) {
                change(u[id], v[id], d[id]);
                sum += d[id];
                tmp.push_back(id);
                R[++rnum] = id;
            }
            else {
                L[++lnum] = id;
            }
        }
        else {
            int cur = Query(dfn[u[id]] + siz[u[id]] - 1) - Query(dfn[u[id]] - 1);
            if (cur == sum) {
                L[++lnum] = id;
            }
            else {
                R[++rnum] = id;
            }
        }
    }
    for (auto X : tmp)
        change(u[X], v[X], -d[X]);
    for (int i = 1; i <= lnum; i++) q[ql + i - 1] = L[i];
    for (int i = 1; i <= rnum; i++) q[ql + lnum + i - 1] = R[i];
    work(ql, ql + lnum - 1, cl, mid);
    work(ql + lnum, qr, mid + 1, cr);
}


void dfs(int u, int fa) {
    f[u][0] = fa;
    dep[u] = dep[fa] + 1;
    dfn[u] = ++tim;
    siz[u] = 1;
    for (int i = 1; i < N; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (auto v : edge[u]) {
        if (v == fa) continue;
        dfs(v, u);
        siz[u] += siz[v];
    }
}

void solve() {
    cin >> n >> m;
    dfn[0] = 1;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs(1, 0);
    int num = 0;
    for (int i = 1; i <= m; i++) {
        int op;
        cin >> op;
        q[i] = i;
        if (op == 0) {
            int a, b, c;
            cin >> a >> b >> c;
            o[i] = 0; 
            d[i] = 1;  
            u[i] = a; 
            v[i] = b; 
            w[i] = c;
        }
        if (op == 1) {
            int a; cin >> a;
            o[i] = 0;
            d[i] = -1;
            u[i] = u[a];
            v[i] = v[a];
            w[i] = w[a];
        }
        if (op == 2) {
            int x;
            cin >> x;
            o[i] = 1;
            u[i] = x;
            w[i] = ++num;
        }
    }
    work(1, m, 0, intinf);
    for (int i = 1; i <= num; i++)
        if (ans[i]) cout << ans[i] << "\n";
        else cout << -1 << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    solve();
    return 0;
}
```

