注意到题目中要求的是**最小美味度** 同时美味度越高 小朋友**能够满足要求的可能性也就越高**(因为可选择的果汁更多了)

所以美味度满足单调性的特征 我们采用二分的方法来解决询问

但是显然对于每个询问都二分一次复杂度过大 所以我们可以考虑使用整体二分法

考虑整体二分的范围 最容易想到的是美味度 $d_i$ 的范围

但其实我们也可以直接将范围定为 $1$ 到 $n$ ，这是因为对于某一个人来说 能作为答案的美味度一定是某一瓶出现过果汁的美味度

这一点利用调整法，是很好证明的 此处略去证明

但是题目中又存在无解 无解的情况我们可以参照之前的讲解 把范围扩大为 $1$ 到 $n + 1$ 

如此一来 解为 $n + 1$ 的组所对应的答案即为 $-1$

然后考虑假设当前二分的果汁为第 $mid$ 瓶之后 如何判断是否满足要求

也就是要高效的求出 $g$ 元钱能够获得多少升果汁

考虑维护一棵值域线段树 

具体地说 叶子结点上代表了**果汁的单价** 而叶子结点挂的值为以 $x$ 为单价的果汁的体积为多少

那么就可以利用线段树算出某一段单价范围内的总体积以及总价

信息合并是简单的 而每次新增果汁相当于是单点修改 所以没有 $down$ 方法

如此一来查询就简单了 我们每次去查询当前单价 $g$ 能获得的最大体积是多少

假设当前查询区间为 $[l,r]$ 中间值为$mid$

那么就判断 如果 $[l,mid]$ 范围内的总价 $\le g$ 那么直接把这个区间内的总体积加上即可 同时去计算右区间 $[mid + 1, r]$ 上的总体积

否则 就继续调用 $[l,mid]$ 上的最大总体积即可





```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-8;
constexpr int intinf = 1e9;

#define lson(x) x << 1
#define rson(x) x << 1 | 1

constexpr int maxn = 6e5 + 10;
constexpr int N = 20;
constexpr int Base = 13;
constexpr int dx[] = { 0,0,1,-1 };
constexpr int dy[] = { 1,-1,0,0 };
constexpr int primes[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43 };
int n, m, q[maxn], ans[maxn], used, maxp, le[maxn], ri[maxn];

ll g[maxn], L[maxn], V[maxn], cost[maxn];

struct node {
    int d; ll p, l;
} a[maxn];

bool cmp(node c1, node c2) {
    return c1.d > c2.d;
}

void up(int p) {
    V[p] = V[lson(p)] + V[rson(p)];
    cost[p] = cost[lson(p)] + cost[rson(p)];
}

void add(int p, int v, int x, int l, int r) {
    if (p == l && p == r) {
        V[x] += v;
        cost[x] = V[x] * p;
        return;
    }
    int mid = (l + r) / 2;
    if (p <= mid) add(p, v, lson(x), l, mid);
    if (p > mid) add(p, v, rson(x), mid + 1, r);
    up(x);
}

ll query(ll Vol, int x, int l, int r) {
    if (l == r) {
        return Vol * l;
    }
    int mid = (l + r) / 2;
    if (V[lson(x)] >= Vol) return query(Vol, lson(x), l, mid);
    else return cost[lson(x)] + query(Vol - V[lson(x)], rson(x), mid + 1, r);
}

void work(int ql, int qr, int cl, int cr) {
    if (ql > qr) return;
    if (cl == cr) {
        for (int i = ql; i <= qr; i++)
            ans[q[i]] = cl;
        return;
    }
    int mid = (cl + cr) / 2;
    while (used < mid) {
        used++;
        add(a[used].p, a[used].l, 1, 1, maxp);
    }
    while (used > mid) {
        add(a[used].p, -a[used].l, 1, 1, maxp);
        used--;
    }
    int lnum = 0, rnum = 0;
    for (int i = ql; i <= qr; i++) {
        int num = q[i];
        if (V[1] >= L[num] && query(L[num], 1, 1, maxp) <= g[num]) {
            le[++lnum] = num;
        }
        else ri[++rnum] = num;
    }
    for (int i = 1; i <= lnum; i++) q[ql + i - 1] = le[i];
    for (int i = 1; i <= rnum; i++) q[ql + i + lnum - 1] = ri[i];
    work(ql, ql + lnum - 1, cl, mid);
    work(ql + lnum, qr, mid + 1, cr);
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i].d >> a[i].p >> a[i].l, maxp = max(maxp, (int)a[i].p);
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= m; i++)
        cin >> g[i] >> L[i], q[i] = i;
    work(1, m, 1, n + 1);
    for (int i = 1; i <= m; i++)
        if (ans[i] == n + 1) cout << -1 << "\n";
        else cout << a[ans[i]].d << "\n";
}

signed main() { 
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```

