# 🌲 重链剖分（Heavy-Light Decomposition, HLD）

重链剖分用于将树拆分成若干条 **重链**，以便**快速维护树上路径或子树相关问题**。  

通常与 **线段树（Segment Tree）** 结合使用，实现树上路径的加、查、最值等操作。

---

## 一、节点需要维护的信息

| 名称     | 含义                                                  |
| -------- | ----------------------------------------------------- |
| `fa[u]`  | 父节点                                                |
| `dep[u]` | 节点深度                                              |
| `siz[u]` | 子树大小                                              |
| `son[u]` | 重儿子（子树规模最大的儿子）                          |
| `top[u]` | 所在重链的头节点                                      |
| `dfn[u]` | DFS 序编号                                            |
| `seg[i]` | DFS 序号为 `i` 的节点编号，用于线段树建树时找到原节点 |

---

## 二、两次 DFS 的作用

### 🌀 第一次 DFS（`dfs1`）

用于计算：

- `fa[u]`（父节点）
- `dep[u]`（深度）
- `siz[u]`（子树大小）
- `son[u]`（重儿子）

> ⚠️ 在此过程中 **不分配 DFS 序号**。

---

### 🌿 第二次 DFS（`dfs2`）

用于计算：

- `top[u]`（当前节点所在重链的头节点）
- `dfn[u]`（DFS 序号）
- `seg[i]`（反向映射：`dfn -> 节点编号`）

遍历方式：

1. 先访问 **重儿子** `son[u]`；
2. 再访问其余 **轻儿子**。

规则：

- 父节点与重儿子在同一条链上，`top` 相同；
- 每个轻儿子开启一条新链，`top[child] = child`。

---

## 三、DFS 序的性质

1. **同一条重链上的节点**：`dfn` 序号连续；
2. **同一棵子树内的节点**：`dfn` 序号也连续。

因此：

- 对子树操作 ⇒ 在线段树上进行单区间操作；
- 对路径操作 ⇒ 分解成若干条重链，逐条处理。

---

## 四、复杂度分析

| 操作类型     | 时间复杂度    |
| ------------ | ------------- |
| 子树操作     | $O(\log n)$   |
| 两点路径操作 | $O(\log^2 n)$ |

---

## 五、求 LCA（最近公共祖先）

树链剖分同样可用于快速求 LCA：

不断让 `u` 和 `v` **向上跳链**，直到它们处于同一条重链上。  
此时深度（或 DFS 序）较小的节点即为 LCA。

---

## 六、边权转点权的处理方法

若题目给出的是 **边权** 而非点权，可以进行如下转化：

> 对于一条边 $(u, v)$，假设 $u$ 是父亲 、 $v$ 是儿子，  
> 则将该边的权值 **下放到深度较大的点 $v$ 上**。

这样：

- 在线段树上只需维护点权；
- 查询路径时，只需统计 **路径上每条边深度较大的点的点权**。

---

## 七、HLD 结构图示（示意）

```text
      1
     / \
    2   3
   / \
  4   5
     / \
    6   7
```

则 $2$ 是 $1$ 的重儿子 , $5$ 是 $2$ 的重儿子 

则链划分结果为：
- 重链 $1$ : $1$ → $2$ → $5$
- 重链 $2$ : $3$
- 重链 $3$ : $4$
- 重链 $4$ : $6$
- 重链 $5$ : $7$

---


| 功能                | 实现原理               | 时间复杂度    |
| ------------------- | ---------------------- | ------------ |
| 子树区间更新 / 查询 | 子树 dfn 连续          | $O(\log n)$    |
| 路径加 / 查         | 分解为若干重链区间操作 | $O(\log^2 n)$  |
| LCA 求解            | 不断上跳重链           | $O(\log n)$   |
| 边权处理            | 下放到深度较大节点     |  $O(1)$        |
