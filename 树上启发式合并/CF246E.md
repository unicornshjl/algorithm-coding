这个问题和 $CF208E$ 高度相似

在查询点 $u$ 第 $k$ 级有多少个不同的儿子节点时采取的思想仍然是启发式合并 

我们去考虑 $u$ 的子树中 深度为 $dep[u] + k$ 的儿子中不同的数量有几个

由于会有重复的元素 我们可以用一个 `set` 来维护当前每个深度的儿子

然后考虑重名的人如何处理 这很简单 我们用一个 `map` 维护即可

剩下的还是离线下来询问 跑一遍启发式合并即可 不再过多赘述



代码如下 $:$



```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 2e5 + 10;
constexpr int N = 20;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

map<string, int> mp;

int n, num, rt[maxn], ans[maxn], siz[maxn], son[maxn], dep[maxn], a[maxn];

vector<int> edge[maxn];
vector<pair<int, int>> q[maxn];
set<int> st[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

void dfs1(int u,int fa) {
    siz[u] = 1;
    dep[u] = dep[fa] + 1;
    for (auto v : edge[u]) {
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[son[u]] < siz[v])
            son[u] = v;
    }
}

void update(int u) {
    st[dep[u]].insert(a[u]);
    for (auto v : edge[u]) {
        update(v);
    }
}

void del(int u) {
    st[dep[u]].erase(a[u]);
    for (auto v : edge[u])
        del(v);
}

void dfs2(int u, int keep) {
    for (auto v : edge[u]) {
        if (v == son[u]) continue;
        dfs2(v, 0);
    }
    if (son[u])
        dfs2(son[u], 1);
    st[dep[u]].insert(a[u]);
    for (auto v : edge[u]) {
        if (v == son[u]) continue;
        update(v);
    }
    for (auto [k, id] : q[u])
        ans[id] = st[dep[u] + k].size();
    if (keep == 0)
        del(u);
}

void solve(int id){
    cin >> n;
    for (int i = 1; i <= n; i++) {
        string s;
        int fa;
        cin >> s >> fa;
        if (!mp.count(s)) {
            mp[s] = mp.size() + 1;
        }
        a[i] = mp[s];
        add(fa, i);
        if (fa == 0){
            rt[++num] = i;
        }
    }
    for (int i = 1; i <= num; i++)
        dfs1(rt[i], 0);
    int Q; cin >> Q;
    for (int i = 1; i <= Q; i++) {
        int u, k;
        cin >> u >> k;
        q[u].push_back({ k,i });
    }
    for (int i = 1; i <= num; i++)
        dfs2(rt[i], 0);
    for (int i = 1; i <= Q; i++)
        cout << ans[i] << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```
