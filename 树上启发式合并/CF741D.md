$CF741D:$

考虑什么时候 $u$ 和 $v$ 之间的路径可能是回文串

那么一定是 $u$ 和 $v$ 之间的路径上的字符中 出现奇数次数的字符数量 $\le 1$ 

关于出现次数奇偶性 我们可以用 $\oplus$ 来处理 同时注意到只有 $22$ 中字母 

所以我们采用状态压缩来保存状态      具体地 我们用 $1$ 表示该字符出现了奇数次 $0$ 表示该字符出现了偶数次

具体地 我们令 $state[u]$ 表示从 $1\to u$ 的状态 

那么我们想要得到 $u\to v$ 上路径的状态 直接用 $state[u] \oplus state[v]$ 就可以得到

因为 $\oplus$ 之后 从 $1$ 到 $LCA(u,v)$ 的路径上的状态值是相同的 一次异或操作之后就被消掉了

那么我们就是要寻找 对于 $u$ 子树中的一个点 去寻找有哪些点的 $state$ 值能够与它配对 同时使得两点间的距离最大

子树内的静态不带修问题 我们可以考虑 树上启发式合并

由于要求距离 所以我们需要保存当前已经加入信息中的 $maxdep[state]$ 表示 $state$ 状态出现的最大深度 因为我们知道树上两点间距离是可以通过深度快速得到的

假设在信息合并时 我们有多种情况需要讨论

首先是父节点直接继承子节点的答案 因为是直接继承答案 所以这**既包括轻儿子也包括重儿子**

然后我们考虑加入新节点 我们知道父节点是保留重儿子上的信息的 所以有一部分节点状态的 $maxdep$ 是已知的 

$1.$ 加入当前节点 $u$ 那么我们需要去判断与 $state[u]$ 异或后至多只有 $1$ 个 $1$ 的状态所对应的 $maxdep$ 是否为 $0$ 如果不为 $0$ 的话 那么就判断距离 $maxdep[State - dep[u]]$ 是否能更新最大值

其中 $State = state[u],state[u]\oplus2^k$  其中 $0\le k\le21$

$2.$更新轻儿子的信息 我们采用树形 $DP$ 的思想来考虑这个问题

假设我们当前考虑的是 $v$ 这个节点 那么我们去判断之前符合 $v$ 的 $State$ 的 $maxdep$ 的状态是否存在不为 $0$ 的 如果不为 $0$ 的话 那么就判断距离能否更新最大值     

而在这里 距离的计算相对困难 

首先我们知道 我们这个计算过程是必定包含当前父节点 $u$ 的 为了不与 $v$ 的父节点弄混 我们记作 $rt$ 

也就是这段距离的长度是从 $maxdep$ 的地方出发 然后到达 $rt$ 再到 $v$ 即 $maxdep[State] + dep[u] - 2\times dep[rt]$

更新完之后 我们把当前轻儿子所在子树的内容加入到节点状态 $maxdep$ 中 保证后续在计算距离的时候考虑到这个轻儿子

这个思想是与树形 $DP$ 中某些题目以此合并子树类似的

收集完以 $u$ 为根的子树答案之后 还是根据当前节点的 `keep` 值决定信息是否保留 若舍弃 直接将子树上所有状态的 $maxdep$ 值赋为 $0$ 即可

总体时间复杂度 $O(22\times N\log N)$

代码如下 $: $

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

constexpr int mod = 998244353;

constexpr int maxn = 5e5 + 10;
constexpr int N = 22;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, son[maxn], state[maxn], siz[maxn], dep[maxn], ans[maxn], cnt;
int nxt[maxn], head[maxn], to[maxn], val[maxn];
int maxdep[(1 << 22) + 10];

void add(int u, int v,int w) {
    to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; val[cnt] = w;
}

void dfs1(int u,int fa) {
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    for (int i = head[u]; i; i = nxt[i]){
        int v = to[i], w = val[i];
        state[v] = state[u] ^ w;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]])
            son[u] = v;
    }
}

void check(int u,int rt) {
    if (maxdep[state[u]])
        ans[rt] = max(ans[rt], maxdep[state[u]] + dep[u] - dep[rt] * 2);
    for (int i = 0; i < N; i++) {
        int cur_state = state[u] ^ (1 << i);
        if (maxdep[cur_state])
            ans[rt] = max(ans[rt], maxdep[cur_state] + dep[u] - dep[rt] * 2);
    }
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        check(v, rt);
    }
}

void update(int u) {
    maxdep[state[u]] = max(maxdep[state[u]], dep[u]);
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        update(v);
    }
}

void clear(int u) {
    maxdep[state[u]] = 0;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        clear(v);
    }
}

void dfs2(int u, int keep) {
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == son[u]) continue;
        dfs2(v, 0);
    }
    if (son[u]) dfs2(son[u], 1);
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        ans[u] = max(ans[u], ans[v]);
    }
    if (maxdep[state[u]])
        ans[u] = max(ans[u], maxdep[state[u]] - dep[u]);
    maxdep[state[u]] = max(maxdep[state[u]], dep[u]);
    for (int i = 0; i < N; i++) {
        int cur_state = state[u] ^ (1 << i);
        if (maxdep[cur_state])
            ans[u] = max(ans[u], maxdep[cur_state] - dep[u]);
    }
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == son[u]) continue;
        check(v, u);
        update(v);
    }
    if (keep == 0)
        clear(u);

}

void solve(int id){
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int u; char c;
        cin >> u >> c;
        int num = c - 97;
        add(u, i,(1 << num));
    }
    dfs1(1, 0);
    dfs2(1,0);
    for (int i = 1; i <= n; i++)
        cout << ans[i] << " ";
    cout << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```
