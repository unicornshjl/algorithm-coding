查询 $v$ 的 $p$ 级表亲有几个 实际上就是查 $v$ 的 $p$ 级祖先的 $p$ 级别儿子数 $-1$ $($$-1$ 是因为不包括其本身$)$

那么我们按照这个思路 将问题分为两部分 首先就是查询 $v$ 的 $p$ 级祖先

这个问题我们可以利用树上倍增快速的得到

然后就是考虑每个节点 $u$ 的 $k$ 级儿子数如何处理

我们发现 $u$ 的 $k$ 级儿子一定是 $u$ 子树内部且深度为 $dep_u + k$ 的节点

那么我们就可以处理出对于所有以 $u$ 为根的子树中 处理出深度 $k$ 的节点有多少个

这样就可以解决查询 $u$ 的 $k$ 级儿子有多少个

那么我们将所有询问离线下来 保存问题的**编号** 该问题所对应的**祖先** 以及 **级数 $k$** 即可

需要注意的是 树的根并非为 $1$ 且并非只有一棵树 所以我们需要记录下所有的根 每次从根开始进行 $dfs$ 即可

代码如下 $:$

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 1e5 + 10;
constexpr int N = 20;
constexpr int base = 29;
constexpr int eps = 1e-7;
constexpr ll inf = 1e15;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, head[maxn], num, f[maxn][N], siz[maxn], son[maxn], m, dep[maxn], cnt[maxn], ans[maxn];

vector<int> edge[maxn];
vector<pair<int, int>> Q[maxn];

void add(int u, int v) {
    edge[u].push_back(v);
}

void ST() {
    for (int i = 1; i < N; i++)
        for (int u = 1; u <= n; u++)
            f[u][i] = f[f[u][i - 1]][i - 1];
}

int up(int u,int dep) {
    for (int i = N - 1; i >= 0; i--)
        if ((dep >> i) & 1) u = f[u][i];
    return u;
}

void dfs1(int u, int fa) {
    f[u][0] = fa;
    siz[u] = 1;
    dep[u] = dep[fa] + 1;
    for (auto v : edge[u]) {
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]]) 
            son[u] = v;
    }
}

void update(int u) {
    cnt[dep[u]]++;
    for (auto v : edge[u])
        update(v);
}

void del(int u) {
    cnt[dep[u]]--;
    for (auto v : edge[u]) 
        del(v);
}

void dfs2(int u, int keep) {
    for (auto v : edge[u]) {
        if (v == son[u]) continue;
        dfs2(v, 0);
    }
    if (son[u]) dfs2(son[u], 1);
    cnt[dep[u]]++;
    for (auto v : edge[u]) {
        if (v == son[u]) continue;
        update(v);
    }
    for (auto [d, id] : Q[u])
        ans[id] = cnt[dep[u] + d] - 1;
    if (keep == 0) del(u);
}

void solve(int id){
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int u;
        cin >> u;
        if (u == 0) head[++num] = i;
        else add(u, i);
    }
    for (int i = 1; i <= num; i++)
        dfs1(head[i], 0);
    ST();
    cin >> m;
    for (int i = 1; i <= m; i++) {
        int u, dep;
        cin >> u >> dep;
        int root = up(u, dep);
        if (root != 0)
            Q[root].push_back({ dep,i });
    }
    for (int i = 1; i <= num; i++)
        dfs2(head[i], 0);
    for (int i = 1; i <= m; i++)
        if (ans[i] == 0) cout << "0 ";
        else cout << ans[i] << " ";
    cout << "\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```



