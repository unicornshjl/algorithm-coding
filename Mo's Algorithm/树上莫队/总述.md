## 树上莫队

------

树上莫队的核心思想是：
 **运用括号序将树上路径问题转化为区间问题，从而可以采用莫队求解。**

------

### 一、括号序的定义

在 树的 $DFS$ 遍历过程中，每个节点会被访问两次，我们为每个节点定义两个时间戳：

- **`st[u]`**：第一次进入节点 `u` 时的时间戳
- **`ed[u]`**：第二次离开节点 `u` 时的时间戳

这两个时间戳共同构成了所谓的 **括号序**。
 因此，一棵树在 DFS 后会有 `2n` 个时间点。

------

### 二、路径到区间的转化

对于任意一条从 **u 到 v** 的路径，我们先假设 `u` 的深度不高于 `v`，然后找到它们的 **最近公共祖先 ( $LCA$ )**。
 接着分两种情况讨论：

#### ✅ 情况 1：`u = LCA(u, v)`

此时路径完全位于 $LCA$ 的一个子树中，
 区间端点为：

```
l = st[u]
r = st[v]
```

------

#### ✅ 情况 2：`v ≠ LCA(u, v)`

此时路径跨越多个子树，
 区间端点为：

```
l = ed[u]
r = st[v]
```

并且需要 **额外记录 LCA 这个点**。
 在区间滑动完成后：

1. 临时将 $LCA$ 加入答案（保证路径完整）
2. 立即删除 $LCA$，避免影响后续查询

------

### 三、区间中的点处理方式

在树上莫队中，我们不再使用普通莫队的 `add()` 和 `dec()`，
 而是采用一个统一的函数 **`change()`**。

其逻辑如下：

- 若当前点尚未被标记，则将其**加入答案**并标记；
- 若当前点已被标记，则将其**从答案中移除**并取消标记。

换句话说：
 区间中 **出现一次的点计入答案**，
 而 **出现两次的点相互抵消**。

------

### 四、带修改的树上莫队

若题目中带有修改操作，则可以直接套用 **带修莫队** 的思路。
 只需引入一个额外的 **时间维度 `T`**，并在滑动过程中同步执行修改。
 这时的整体算法相当于 **“树上 + 带修” 莫队**。

------

### 五、复杂度分析

- 树上莫队的本质是对 **括号序** 进行莫队操作，因此序列长度为 **`N = 2n`**。
- 时间复杂度取决于采用的莫队类型：
  - 若是普通莫队：$O(N \times \sqrt{N})$
  - 若是带修莫队：$O(N^{\frac{5}{3}})$
