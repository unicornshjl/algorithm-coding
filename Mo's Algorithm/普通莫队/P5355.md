此题我们使用 莫队 $+$ `bitset` 实现 同时结合 $DP$ 根号分治等思想

首先考虑差为 $x$ 的情况

我们维护一个 `bitset` $cur$ 来表示当前出现的数字 $a_i$ 情况

例如 $cur$ 的第 $i$ 位为 $1$ 和 $0$ 分别表示当前区间出现 $/$ 没出现 $i$ 这个数字

我们假设存在两个数字 $p$ 和 $q$ 满足 $p - q = x$ 且 $p$ 与 $q$ 均在该区间出现

那么显然 $cur$ 的第 $p$ 位和第 $q$ 位上的数字都应为 $1$

由于 $p - q = x$ 所以 $q = p - x$

那么也就是 如果存在这样的一组 $p$ 和 $q$  需要满足的条件为

`((cur >> x) & cur)` 存在 $1$ 

譬如若 `cur = 1110` 表示同时存在  $2$  $3$ 和 $4$ 

我们假设 $x$ 为 $2$ 那么此时 `cur >> x = 0011` 

可以发现两者相与的结果 `0010` 在第 $2$ 位上仍然为 $1$ 

然后考虑维护和为 $x$ 的情况

此时我们不仅需要一个 `bitset` $cur$ 来维护出现数字 $a_i$ 情况

我们假设存在两个数字 $p$ 和 $q$ 满足 $p + q = x$ 

那么 $q = x - p$ 这样仅仅依靠 $cur$ 我们是无法进行判断的

所以，我们还需要一个 $rev$ 来表示 $V-a_i$ 出现的数字情况 $($ $V$ 为数组 $a$ 的上限值 $)$

为什么呢 因为 $p = x - q$ 可以变形为 $q + (V - x) = (V - p)$

那么我们要判断的就是 $V-p$ 所在的 `bitset` 与 $q$ 所在 $bitset$ 左移 $V - x$ 位的结果是否有公共 $1$

即` ((cur << (V - x)) & rev ` 是否存在 $1$

接下来我们考虑积为 $x$ 的情况

这种情况比较简单 我们分解 $x$ 的因数即可 这样我们便可以在 $O(\sqrt{x})$ 的复杂度内判断 该复杂度可以接受

具体的说 我们从 $1$ 到 $\sqrt{x}$ 枚举 $p$ 若 $p$ 为 $x$ 的因数 且在 $cur$上 第 $p$ 位和第 $\frac{x}{p}$ 位均为 $1$ 则表明存在积为 $x$

最后考虑商为 $x$ 的情况

该情况我们需要采用根号分治的思想

若 $x > \sqrt{V}$ 我们可以暴力枚举 $p$ 那么 $q = p \times x$

由于 $x > \sqrt{V}$  枚举的次数是不会超过 $\sqrt{V}$ 的

若 $x<\sqrt{V}$ 那么我们不采用莫队 而是采用线性 $DP$ 来解决这个问题



代码如下 : 

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

//#define int long long
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

#define lson(x) (x << 1)
#define rson(x) (x << 1 | 1)

inline int lowbit(int x) {
    return x & (-x);
}

constexpr int maxn = 1e5 + 10;

constexpr int mod = 1e9 + 7;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-7;
constexpr int intinf = 1e9 + 10;

int n, m, a[maxn], cnt, ans[maxn], V = 100000, f[maxn], vis[maxn], h[maxn];

struct node {
    int l, r, bl, op, id, val;
} q[maxn];

struct no {
    int l, r, id;
};

int d = sqrt(100000);

vector<no> Q[320];


bitset<100001> cur, rev;

bool cmp(node c1, node c2) {
    if (c1.bl == c2.bl) {
        if (c1.bl & 1) return c1.r < c2.r;
        return c1.r > c2.r;
    }
    return c1.bl < c2.bl;
}

void add(int x) {
    h[x]++;
    if (h[x] == 1) {
        cur.set(x);
        rev.set(V - x);
    }
}

void del(int x) {
    h[x]--;
    if (h[x] == 0) {
        cur.reset(x);
        rev.reset(V - x);
    }
}

void solve(int id) {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int B = sqrt(n);
    for (int i = 1; i <= m; i++) {
        int op, l, r, x;
        cin >> op >> l >> r >> x;
        if (op == 4 && x < d) {
            Q[x].push_back({ l,r,i });
        }
        else {
            q[++cnt] = { l,r,(l - 1) / B + 1,op,i,x };
        }
    }

    for (int i = 1; i < d; i++) {
        for (int j = 1; j <= n; j++) f[j] = 0;
        for (int j = 1; j <= V; j++) vis[j] = 0;
        for (int j = 1; j <= n; j++) {
            vis[a[j]] = j;
            f[j] = f[j - 1];
            if (a[j] * i <= V) f[j] = max(f[j], vis[a[j] * i]);
            if (a[j] % i == 0)
                f[j] = max(f[j], vis[a[j] / i]);
        }
        for (auto [l, r, id] : Q[i]) 
            if (f[r] >= l) ans[id] = 1;
    }

    sort(q + 1, q + cnt + 1, cmp);

    int l = 1, r = 0;
    for (int i = 1; i <= cnt; i++) {
        while (l > q[i].l) add(a[--l]);
        while (r < q[i].r) add(a[++r]);
        while (l < q[i].l) del(a[l++]);
        while (r > q[i].r) del(a[r--]);
        int id = q[i].id, op = q[i].op, x = q[i].val;
        bitset<100001> test;
        if (op == 1) {
            test = ((cur >> x) & cur);
            if (test.any()) ans[id] = 1;
        }
        if (op == 2) {
            test = ((cur << (V - x)) & rev);
            if (test.any()) ans[id] = 1;
        }
        if (op == 3) {
            for (int j = 1; j * j <= x; j++)
                if (x % j == 0) {
                    if (cur[j] && cur[x / j])
                        ans[id] = 1;
                }
        }
        if (op == 4) {
            for (int j = 1; j * x <= V; j++)
                if (cur[j] && cur[j * x]) ans[id] = 1;
        }
    }
    for (int i = 1; i <= n; i++)
        if (ans[i]) cout << "yuno\n";
        else cout << "yumi\n";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);
    return 0;
}
```
