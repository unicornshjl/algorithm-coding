贝祖定理 : 

如果 $a$ 和 $b$ 是不全为 $0$ 的整数 则一定存在整数 $x$ 、 $y$ 使得 $ax+by=gcd(a,b)$

推论

如果 $a$ 和 $b$ 是不全为 $0$ 的整数 $a$ 和 $b$ 互质 那么一定存在整数 $x$ 、 $y$ 使得 $ax + by = 1$

如果 $a$ 和 $b$ 是不全为 $0$ 的整数 并且 $ax+by=c$ 有解 那么 $c = k \times gcd(a,b)$ 其中 $k$ 是一个整数



扩展欧几里得算法

对于方程 $ax + by = gcd(a,b)$ 当 $a$ $b$ 确定 那么 $gcd(a,b)$ 也确定 要保证参数 $a$ $b$ 没有负数

在 $gcd$ 的过程中 假设我们现在是从 $gcd(a',b')$ 倒推到 $gcd(a,b)$ 的过程中 考虑如何得到 $x、y$

$d = x'a'+y'b'$

由于 $a' = b$  $b' = a \% b$ 

所以 $d = x'b + y'(a\%b) = x'b + y'(a - a / b \times b) = y'a + (x' - y'\times a / b)b$

所以$x = y',y = x' - a/b\times y'$

递归的终止条件为 $b = 0$ 时 $d = a$ 所以 $x = 1,y = 0$



当我们得到一组特解 $x_0,y_0$ 时通解可以表示为 $x = x_0 + (b / d) \times k 、y = y_0 - (a / d) \times k$ 其中 $k$ 为任意整数

$\because ax_0 + by_0 = d$  $\therefore ax + by = a(x_0 + (b / d) \times k) + b(y_0 - (a / d) \times k ) = ax_0 + by_0 = d$ 

对于方程 $ax + by = c$

已知 $c = td$ 那么原方程的解为 $x = c/d \times x_0 、 y = c / d \times y_0$


理论时间复杂度 $O(log \min(a,b))$ 但是由于 $\%$ 的巨大常数 实际上的时间复杂度可能达到理论复杂度的 $3$ 倍



中国剩余定理 (CRT) : 


#### 1. 🎯 问题描述

我们要求解一个线性同余方程组:
$$
\begin{cases}
x \equiv r_1 \pmod{m_1} \\
x \equiv r_2 \pmod{m_2} \\
\dots \\
x \equiv r_n \pmod{m_n}
\end{cases}
$$
核心前提: 模数 $m_1, m_2, \dots, m_n$ 两两互质.

目标: 找到满足所有方程的 $x$.

------



#### 2. 💡 核心思想: 构造法

思想 ：拆分法. 我们尝试构造一个解 $x$, 使得 $x$ 是 $n$ 个部分的和:

$x = c_1 + c_2 + \dots + c_n$

我们对这 $n$ 个部分 $c_i$ 提出以下要求:

- **对于 $c_i$**:
  - $c_i \equiv r_i \pmod{m_i}$ (它满足第 $i$ 个方程)
  - $c_i \equiv 0 \pmod{m_j}$ (对于所有 $j \neq i$, 它不"干扰"其他方程)

**为什么这样可行?**

让我们来验证一下. 当我们求解 $x \pmod{m_k}$ (即第 $k$ 个方程) 时:

$x \pmod{m_k} = (c_1 + c_2 + \dots + c_k + \dots + c_n) \pmod{m_k}$

根据我们的要求, 所有 $j \neq k$ 的 $c_j$ 模 $m_k$ 都为 $0$. 所以:

$x \pmod{m_k} = (0 + 0 + \dots + c_k + \dots + 0) \pmod{m_k}$

$x \pmod{m_k} = c_k \pmod{m_k}$

而我们又要求 $c_k \equiv r_k \pmod{m_k}$. 因此, 这样构造出的 $x$ 自动满足所有 $n$ 个方程.

$x \equiv r_k \pmod{m_k}$ (对所有 $k=1, \dots, n$ 成立)

------



#### 3. 🛠️ 如何构造 $c_i$



现在的问题是如何构造满足条件的 $c_i$.

1. 定义 $M$:

   令 $M = \prod_{k=1}^n m_k = m_1 \times m_2 \times \dots \times m_n$. (由于 $m_i$ 两两互质, $M$ 也是它们的最小公倍数 $LCM$).

2. 定义 $M_i$:

   我们需要一个数, 它是 $m_i$ 之外所有模数的倍数.

   令 $M_i = M / m_i = \prod_{j \neq i} m_j$.

3. **分析 $M_i$**:

   - $M_i$ 显然是所有 $m_j$ (当 $j \neq i$) 的倍数, 所以 $M_i \equiv 0 \pmod{m_j}$ (其中 $j \neq i$).
   - 这已经满足了 $c_i$ 的第二个条件. 我们只需要在 $M_i$ 的基础上进行缩放, 使其满足第一个条件 $c_i \equiv r_i \pmod{m_i}$.

4. 求解 $c_i$:

   我们希望 $c_i$ 是 $M_i$ 的倍数 (这样才能保证 $c_i \equiv 0 \pmod{m_j}$), 设 $c_i = k \times M_i$.

   我们需要 $c_i \equiv r_i \pmod{m_i}$, 即:

   $k \times M_i \equiv r_i \pmod{m_i}$

   为了解出 $k$, 我们需要 $M_i$ 在模 $m_i$ 意义下的**乘法逆元**.

   - 为什么逆元存在?

     因为 $m_i$ 与所有其他的 $m_j$ ($j \neq i$) 都互质, 所以 $m_i$ 与它们的乘积 $M_i$ 也必然互质. 根据 $\gcd(M_i, m_i) = 1$, 逆元必定存在.

   - 构造:

     设 $t_i = (M_i)^{-1} \pmod{m_i}$. (即 $t_i$ 是 $M_i$ 模 $m_i$ 的逆元, 满足 $t_i \times M_i \equiv 1 \pmod{m_i}$)

     现在, 我们在 $k \times M_i \equiv r_i \pmod{m_i}$ 两边同乘 $t_i$:

     $k \times M_i \times t_i \equiv r_i \times t_i \pmod{m_i}$

     $k \times 1 \equiv r_i \times t_i \pmod{m_i}$

     $k = r_i \times t_i$

   我们找到了 $k$, 把它代回 $c_i = k \times M_i$:

   $c_i = r_i \times t_i \times M_i$

------


#### 4. 🧮 算法步骤总结

1. 计算 $M = \prod_{i=1}^n m_i$. (如果 $n$ 很大, 这一步可能需要高精度乘法).
2. 初始化特解 $x_0 = 0$.
3. 对于 $i = 1$ 到 $n$:
   - a. 计算 $M_i = M / m_i$.
   - b. 使用 **扩展欧几里得算法 (exgcd)** 计算 $M_i$ 在模 $m_i$ 意义下的逆元 $t_i$. (即求解 $M_i \times t_i + m_i \times y = 1$ 中的 $t_i$).
   - c. 计算 $c_i = r_i \times M_i \times t_i$. (注意: $c_i$ 可能很大).
   - d. 累加到特解: $x_0 = x_0 + c_i$.
4. **特解**: $x_0 = \sum_{i=1}^n c_i$ 是方程组的一个特解.
5. **通解**: 通解为 $x = x_0 + k \times M$ (其中 $k$ 为任意整数). (注意: 你笔记中最后写的 $mul$ 应该是 $M$).
6. **最小非负整数解**: 题目通常要求最小非负整数解, 即 $x_0 \pmod M$.
   - **实现技巧**: 为了防止 $x_0$ 累加过程中溢出, 可以在每一步累加时就取模: $x_0 = (x_0 + c_i) \pmod M$.
   - **最终答案**: $(x_0 \pmod M + M) \pmod M$. (使用 `(x % M + M) % M` 是一个好习惯, 可以防止 $x_0$ 计算过程中出现负数).
