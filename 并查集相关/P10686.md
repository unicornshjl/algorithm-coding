看到将小朋友(点)分组的题目 容易想到并查集

由于小朋友分成了三组 这三组的关系又是一个环状的攻击关系

受到“食物链”的启发 , 我们想到**种类并查集**

用 $X$ 表示和自己手势相同的同学 用 $X + n$ 表示自己能够战胜手势的同学 用 $X + 2 \times n$ 表示战胜自己手势的同学

那么我们就将问题转化为了和“食物链”完全相同的问题

因为 $a = b$ 其实就是 $a$ 和 $b$ 为同种  而$ a > b$ 和 $a < b$ 描述的其实就是 “吃” 的关系

那么我们考虑如何找到裁判 首先我们已经知道裁判的手势是任意的 而且裁判有且只有一个

又观察到题目的数据范围 $N \le 500,M \le 2000 $ 那么我们可以**枚举谁是裁判**

假设枚举了 $judge$ 作为裁判 

那么对于题目中所给定的 $M$ 条关系 

与 $judge$ 有关的我们直接忽视 如果剩下的条件没有矛盾 那么 $judge$ 可以作为裁判

如果这样的 $judge$ 个数为 $0$ 说明 `Impossible`  如果个数 $>1$ 则说明 `Can not determine`

而当 $judge$ 只有一个的时候 才是合法的 接下来我们考虑如何找到确定裁判的最小轮次

首先 **裁判是一定会与他人冲突的** 

那么是我们发现冲突的那一回合就找到了吗？**并不是**

因为既然裁判跟 $x$ 冲突了 那么 $x$ 也就和 $judge$ 冲突了 当我们第一次发现冲突的时候 我们并不能锁定谁是裁判

而当我们**第二次**冲突的时候 可以保证此时找到了裁判 

因为其他人内部之间不会再**出现冲突** 所以能保证其他人可能且只可能跟裁判发生冲突

所以其他人冲突的次数至多为 $1$ 

而我们保证了有且只有一个裁判

所以其他人和裁判冲突的次数必定是 $\ge 2$ 的 否则每个人产生次数最多为 $1$ 那么就存在多于 $1$ 个裁判 与此时情况不符



于是代码如下

```cpp
#include<algorithm>
#include<bitset>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<map>
#include<queue>
#include<set>
#include<string>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<random>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

constexpr ll mod = 998244353;

constexpr int maxn = 2e5 + 10;
constexpr ll base = 131;
constexpr ll inf = 1e18;
constexpr ld eps = 1e-7;
constexpr int intinf = 1e9 + 10;
constexpr int dx[] = { 1,-1,0,0 };
constexpr int dy[] = { 0,0,1,-1 };

int n, m, f[maxn], x[maxn], y[maxn];

char op[maxn];

int find(int x) {
    return (f[x] == x ? x : f[x] = find(f[x]));
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    f[y] = x;
}

void solve() {
    for (int i = 1; i <= m; i++) 
        cin >> x[i] >> op[i] >> y[i];
    if (n == 1) {
        cout << "Player 0 can be determined to be the judge after 0 lines\n";
        return;
    }
    int judger = 0;
    for (int judge = 1; judge <= n; judge++) {
        for (int i = 1; i <= 3 * n; i++) f[i] = i;
        bool flag = true;
        for (int i = 1; i <= m; i++) {
            int u = x[i] + 1, v = y[i] + 1;
            if (u == judge || v == judge) continue;
            char ch = op[i];
            if (ch == '<') {
                if (find(u) == find(v) || find(u + n) == find(v)) {
                    flag = false; break;
                }
                merge(v + n, u);
                merge(u + 2 * n, v);
                merge(u + n, v + 2 * n);
            }
            if (ch == '>') {
                swap(u, v);
                if (find(u) == find(v) || find(u + n) == find(v)) {
                    flag = false; break;
                }
                merge(v + n, u);
                merge(u + 2 * n, v);
                merge(u + n, v + 2 * n);
            }
            if (ch == '=') {
                if (find(u) == find(v + n) || find(u) == find(v + 2 * n)) {
                    flag = false; break;
                }
                merge(u, v);
                merge(u + n, v + n);
                merge(u + 2 * n, v + 2 * n);
            }
        }
        if (flag) {
            if (judger == 0) {
                judger = judge;
            }
            else {
                cout << "Can not determine\n";
                return;
            }
        }
    }
    if (judger == 0) {
        cout << "Impossible\n";
        return;
    }
    for (int i = 1; i <= n * 3; i++) f[i] = i;
    int res = 0;
    for (int i = 1; i <= m; i++) {
        int u = x[i] + 1, v = y[i] + 1;
        char ch = op[i];
        if (ch == '<') {
            if (find(u) == find(v) || find(u + n) == find(v)) {
                res++;
                if (res == 2) {
                    cout << "Player " << judger - 1 << " can be determined to be the judge after " << i << " lines\n";
                    return;
                }
                continue;
            }
            merge(v + n, u);
            merge(u + 2 * n, v);
            merge(u + n, v + 2 * n);
        }
        if (ch == '>') {
            swap(u, v);
            if (find(u) == find(v) || find(u + n) == find(v)) {
                res++;
                if (res == 2) {
                    cout << "Player " << judger - 1 << " can be determined to be the judge after " << i << " lines\n";
                    return;
                }
                continue;
            }
            merge(v + n, u);
            merge(u + 2 * n, v);
            merge(u + n, v + 2 * n);
        }
        if (ch == '=') {
            if (find(u) == find(v + n) || find(u) == find(v + 2 * n)) {
                res++;
                if (res == 2) {
                    cout << "Player " << judger - 1 << " can be determined to be the judge after " << i << " lines\n";
                    return;
                }
                continue;
            }
            merge(u, v);
            merge(u + n, v + n);
            merge(u + 2 * n, v + 2 * n);
        }
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    /*int T = 1;
    //cin >> T;
    for (int i = 1; i <= T; i++)
        solve(i);*/
    while (cin >> n >> m) {
        solve();
    }
    return 0;
}
```



